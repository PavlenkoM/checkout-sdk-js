{"version":3,"file":"integrations/stripe.js","mappings":"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KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,M,uSCnMW,MAAMC,GAUjB,WAAArkB,CACY4D,EACAC,EACA2U,EACA8L,GAHA,KAAA1gB,0BAAAA,EACA,KAAAC,aAAAA,EACA,KAAA2U,yBAAAA,EACA,KAAA8L,iBAAAA,CACT,CAEG,UAAAxgB,CACFC,G,yCAEA,MAAM,UAAEoY,GAAcpY,GAAW,CAAC,EAElC,IAAKoY,EACD,MAAM,IAAIzb,EACN,iEAIR,MAAM,SAAEuD,EAAQ,UAAEC,EAAS,UAAEsb,GAAcrD,EAE3C,IAAKqD,IAAcvb,IAAaC,EAC5B,MAAM,IAAI5B,EAAoB5D,EAAwB8D,uBAG1D,MAAMiE,QAAcnG,KAAK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","sources":["webpack://@bigcommerce/checkout-sdk/webpack/bootstrap","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/missing-data-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts","webpack://@bigcommerce/checkout-sdk/webpack/runtime/define property getters","webpack://@bigcommerce/checkout-sdk/webpack/runtime/hasOwnProperty shorthand","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-argument-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/payment/is-hosted-intrument-like.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/payment/is-vaulted-instrument.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-required-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/is-request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-cancelled-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/is-individual-card-element-options.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/stripev3.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/stripev3-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/stripev3-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/billing/is-billing-address-like.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-client-unavailable-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/stripev3-script-loader.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripev3/create-stripev3-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/stripe.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/stripe-script-loader.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-failed-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/stripe-integration-service.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/is-stripe-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/is-stripe-payment-method-like.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/stripe-supported-locales.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/format-locale.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/stripe-upe/stripe-upe-constants.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-upe/is-stripe-accelerated-checkout-customer.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-upe/stripe-upe-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-upe/create-stripe-upe-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-utils/src/is-stripe-payment-event.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/stripe-ocs-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/create-stripe-ocs-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-cs/stripe-cs-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-cs/create-stripe-cs-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-upe/stripe-upe-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-upe/create-stripe-upe-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/ui/src/loading-indicator/loading-indicator.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/common/utility/amount-transformer.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/constants.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/stripe-link-v2-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/create-stripe-link-v2-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/stripe-link-v2-button-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/stripe-integration/src/stripe-ocs/create-stripe-link-v2-button-strategy.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import StandardError from './standard-error';\n\nexport enum MissingDataErrorType {\n    MissingBillingAddress,\n    MissingCart,\n    MissingCheckout,\n    MissingConsignments,\n    MissingCustomer,\n    MissingCheckoutConfig,\n    MissingOrder,\n    MissingOrderConfig,\n    MissingOrderId,\n    MissingPayment,\n    MissingPaymentId,\n    MissingPaymentInstrument,\n    MissingPaymentMethod,\n    MissingPaymentRedirectUrl,\n    MissingPaymentStatus,\n    MissingPaymentToken,\n    MissingShippingAddress,\n}\n\n/**\n * Throw this error when data that is expected to exist is missing. Usually it\n * is due to the fact that certain data has not been retrieved from or saved to\n * the server yet. And such data is required to perform certain actions.\n */\nexport default class MissingDataError extends StandardError {\n    constructor(public subtype: MissingDataErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'MissingDataError';\n        this.type = 'missing_data';\n    }\n}\n\nfunction getErrorMessage(type: MissingDataErrorType): string {\n    switch (type) {\n        case MissingDataErrorType.MissingBillingAddress:\n            return 'Unable to proceed because billing address data is unavailable.';\n\n        case MissingDataErrorType.MissingCart:\n            return 'Unable to proceed because cart data is unavailable.';\n\n        case MissingDataErrorType.MissingConsignments:\n            return 'Unable to proceed because consignments data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckout:\n            return 'Unable to proceed because checkout data is unavailable.';\n\n        case MissingDataErrorType.MissingCustomer:\n            return 'Unable to proceed because customer data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckoutConfig:\n        case MissingDataErrorType.MissingOrderConfig:\n            return 'Unable to proceed because configuration data is unavailable.';\n\n        case MissingDataErrorType.MissingOrder:\n            return 'Unable to proceed because order data is unavailable.';\n\n        case MissingDataErrorType.MissingOrderId:\n            return 'Unable to proceed because order ID is unavailable or not generated yet.';\n\n        case MissingDataErrorType.MissingPayment:\n            return 'Unable to proceed because payment data is unavailable.';\n\n        case MissingDataErrorType.MissingPaymentToken:\n            return 'Unable to proceed because the token required to submit a payment is missing.';\n\n        case MissingDataErrorType.MissingPaymentMethod:\n            return 'Unable to proceed because payment method data is unavailable or not properly configured.';\n\n        case MissingDataErrorType.MissingShippingAddress:\n            return 'Unable to proceed because shipping address data is unavailable.';\n\n        default:\n            return 'Unable to proceed because the required data is unavailable.';\n    }\n}\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import InvalidArgumentError from './invalid-argument-error';\n\n/**\n * This error should be thrown when we are unable to submit a payment because\n * the caller has not provided all the required fields, i.e.: if an argument is\n * missing or it is not the expected data type.\n */\nexport default class PaymentArgumentInvalidError extends InvalidArgumentError {\n    constructor(invalidFields?: string[]) {\n        let message = 'Unable to submit payment for the order because the payload is invalid.';\n\n        if (invalidFields) {\n            message = `${message} Make sure the following fields are provided correctly: ${invalidFields.join(\n                ', ',\n            )}.`;\n        }\n\n        super(message);\n\n        this.name = 'PaymentArgumentInvalidError';\n    }\n}\n","import { HostedInstrument } from './payment';\n\nexport default function isHostedInstrumentLike(\n    instrument: unknown,\n): instrument is HostedInstrument {\n    return (\n        typeof instrument === 'object' &&\n        instrument !== null &&\n        (typeof (instrument as HostedInstrument).shouldSaveInstrument === 'undefined' ||\n            typeof (instrument as HostedInstrument).shouldSaveInstrument === 'boolean') &&\n        (typeof (instrument as HostedInstrument).shouldSetAsDefaultInstrument === 'undefined' ||\n            typeof (instrument as HostedInstrument).shouldSetAsDefaultInstrument === 'boolean')\n    );\n}\n","import {\n    FormattedPayload,\n    FormattedVaultedInstrument,\n    HostedVaultedInstrument,\n    PaymentInstrumentPayload,\n    VaultedInstrument,\n} from './payment';\n\nexport default function isVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is VaultedInstrument {\n    return Boolean((instrument as VaultedInstrument).instrumentId);\n}\n\nexport function isHostedVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is HostedVaultedInstrument {\n    return (\n        Boolean((instrument as HostedVaultedInstrument).instrumentId) &&\n        !Object.prototype.hasOwnProperty.call(instrument, 'ccNumber') &&\n        !Object.prototype.hasOwnProperty.call(instrument, 'ccCvv')\n    );\n}\n\nexport function isFormattedVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is FormattedPayload<FormattedVaultedInstrument> {\n    const formattedInstrument = (instrument as FormattedPayload<FormattedVaultedInstrument>)\n        .formattedPayload;\n\n    if (!formattedInstrument) {\n        return false;\n    }\n\n    return (\n        typeof formattedInstrument.bigpay_token === 'string' ||\n        Boolean(formattedInstrument.bigpay_token && formattedInstrument.bigpay_token.token)\n    );\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we are trying to make an order finalization request for a\n * payment method that does not require such procedure.\n */\nexport default class OrderFinalizationNotRequiredError extends StandardError {\n    constructor() {\n        super('The current order does not need to be finalized at this stage.');\n\n        this.name = 'OrderFinalizationNotRequiredError';\n        this.type = 'order_finalization_not_required';\n    }\n}\n","import RequestError from './request-error';\n\n// Have to use `as` https://stackoverflow.com/questions/73987044/typeguarding-an-unknown-nested-object should be fixed in 4.8+\nconst isRequestError = (error: unknown): error is RequestError => {\n    return typeof error === 'object' && error !== null && 'body' in error;\n};\n\nexport default isRequestError;\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the payment flow is cancelled. It could be\n * due to a deliberate user interaction, i.e.: the user clicks on a cancel\n * button which dismisses the payment modal.\n */\nexport default class PaymentMethodCancelledError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Payment process was cancelled.');\n\n        this.name = 'PaymentMethodCancelledError';\n        this.type = 'payment_cancelled';\n    }\n}\n","import { IndividualCardElementOptions } from './stripev3';\n\nexport default function isIndividualCardElementOptions(\n    individualCardElementOptions: any,\n): individualCardElementOptions is IndividualCardElementOptions {\n    return (\n        individualCardElementOptions !== null &&\n        typeof individualCardElementOptions === 'object' &&\n        'cardNumberElementOptions' in individualCardElementOptions &&\n        'cardCvcElementOptions' in individualCardElementOptions &&\n        'cardExpiryElementOptions' in individualCardElementOptions &&\n        typeof individualCardElementOptions.cardNumberElementOptions !== 'undefined' &&\n        typeof individualCardElementOptions.cardCvcElementOptions !== 'undefined' &&\n        typeof individualCardElementOptions.cardExpiryElementOptions !== 'undefined'\n    );\n}\n","interface BaseElementOptions {\n    /**\n     * Customize the appearance of an element using CSS properties passed in a [Style](https://stripe.com/docs/js/appendix/style) object,\n     * which consists of CSS properties nested under objects for each variant.\n     */\n    style?: StripeElementStyle;\n\n    /**\n     * Set custom class names on the container DOM element when the Stripe element is in a particular state.\n     */\n    classes?: StripeElementClasses;\n\n    /**\n     * Applies a disabled state to the Element such that user input is not accepted. Default is false.\n     */\n    disabled?: boolean;\n}\n\nexport interface CreatePaymentMethodCardData extends PaymentMethodCreateParams {\n    card?: StripeElement;\n}\n\nexport interface CreatePaymentMethodIdealData extends PaymentMethodCreateParams {\n    ideal?: StripeElement;\n}\n\nexport interface CreatePaymentMethodSepaData extends PaymentMethodCreateParams {\n    sepa_debit?: StripeElement;\n}\n\n/**\n * The PaymentIntent object.\n */\nexport interface PaymentIntent {\n    /**\n     * Unique identifier for the object.\n     */\n    id: string;\n\n    /**\n     * Status of this PaymentIntent. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).\n     */\n    status: 'succeeded' | string;\n\n    /**\n     * The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.\n     */\n    last_payment_error: LastPaymentError | null;\n}\n\n/**\n * The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.\n */\nexport interface LastPaymentError {\n    /**\n     * A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.\n     */\n    message?: string;\n}\n\n/**\n * The PaymentMethod object\n */\nexport interface PaymentMethod {\n    /**\n     * Unique identifier for the object.\n     */\n    id: string;\n\n    /**\n     * The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value.\n     * It contains additional information specific to the PaymentMethod type.\n     */\n    type: string;\n}\n\nexport interface PaymentMethodCreateParams {\n    /**\n     * Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.\n     */\n    billing_details?: StripeBillingDetails;\n}\n\nexport interface StripeError {\n    /**\n     * A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.\n     */\n    message?: string;\n\n    /**\n     * The PaymentIntent object.\n     */\n    payment_intent: PaymentIntent;\n\n    /**\n     * A human-readable code for the error obtained\n     */\n    code?: string;\n}\n\n/**\n * CSS properties supported by Stripe.js.\n */\ninterface StripeElementCSSProperties {\n    /**\n     * The [background-color](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color) CSS property.\n     *\n     * This property works best with the `::selection` pseudo-class.\n     * In other cases, consider setting the background color on the element's container instaed.\n     */\n    backgroundColor?: string;\n\n    /**\n     * The [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color) CSS property.\n     */\n    color?: string;\n\n    /**\n     * The [font-family](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) CSS property.\n     */\n    fontFamily?: string;\n\n    /**\n     * The [font-size](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size) CSS property.\n     */\n    fontSize?: string;\n\n    /**\n     * The [font-smoothing](https://developer.mozilla.org/en-US/docs/Web/CSS/font-smoothing) CSS property.\n     */\n    fontSmoothing?: string;\n\n    /**\n     * The [font-style](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style) CSS property.\n     */\n    fontStyle?: string;\n\n    /**\n     * The [font-variant](https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant) CSS property.\n     */\n    fontVariant?: string;\n\n    /**\n     * The [font-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight) CSS property.\n     */\n    fontWeight?: string;\n\n    /**\n     * A custom property, used to set the color of the icons that are rendered in an element.\n     */\n    iconColor?: string;\n\n    /**\n     * The [line-height](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height) CSS property.\n     *\n     * To avoid cursors being rendered inconsistently across browsers, consider using a padding on the element's container instead.\n     */\n    lineHeight?: string;\n\n    /**\n     * The [letter-spacing](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing) CSS property.\n     */\n    letterSpacing?: string;\n\n    /**\n     * The [text-align](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align) CSS property.\n     *\n     * Available for the `cardNumber`, `cardExpiry`, and `cardCvc` elements.\n     */\n    textAlign?: string;\n\n    /**\n     * The [padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding) CSS property.\n     *\n     * Available for the `idealBank` element.\n     * Accepts integer `px` values.\n     */\n    padding?: string;\n\n    /**\n     * The [text-decoration](https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration) CSS property.\n     */\n    textDecoration?: string;\n\n    /**\n     * The [text-shadow](https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow) CSS property.\n     */\n    textShadow?: string;\n\n    /**\n     * The [text-transform](https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform) CSS property.\n     */\n    textTransform?: string;\n}\n\ninterface StripeElementStyleVariant extends StripeElementCSSProperties {\n    ':hover'?: StripeElementCSSProperties;\n\n    ':focus'?: StripeElementCSSProperties;\n\n    '::placeholder'?: StripeElementCSSProperties;\n\n    '::selection'?: StripeElementCSSProperties;\n\n    ':-webkit-autofill'?: StripeElementCSSProperties;\n\n    /**\n     * Available for all elements except the `paymentRequestButton` element\n     */\n    ':disabled'?: StripeElementCSSProperties;\n\n    /**\n     * Available for the `cardNumber`, `cardExpiry`, and `cardCvc` elements.\n     */\n    '::-ms-clear'?: StripeElementCSSProperties & { display: string };\n}\n\nexport interface CardElementOptions extends BaseElementOptions {\n    /**\n     * A pre-filled set of values to include in the input (e.g., {postalCode: '94110'}).\n     * Note that sensitive card information (card number, CVC, and expiration date)\n     * cannot be pre-filled\n     */\n    value?: string;\n\n    /**\n     * Hide the postal code field. Default is false. If you are already collecting a\n     * full billing address or postal code elsewhere, set this to true.\n     */\n    hidePostalCode?: boolean;\n\n    /**\n     * Appearance of the icon in the Element.\n     */\n    iconStyle?: IconStyle;\n\n    /*\n     * Hides the icon in the Element, Default is false\n     */\n    hideIcon?: boolean;\n}\n\ninterface BaseIndividualElementOptions extends BaseElementOptions {\n    containerId: string;\n}\n\nexport interface CardNumberElementOptions extends BaseIndividualElementOptions {\n    /*\n     * Placeholder\n     */\n    placeholder?: string;\n\n    showIcon?: boolean;\n    /**\n     * Appearance of the icon in the Element. Either `solid` or `default`\n     */\n    iconStyle?: IconStyle;\n}\n\nexport interface CardExpiryElementOptions extends BaseIndividualElementOptions {\n    /*\n     * Placeholder\n     */\n    placeholder?: string;\n}\n\nexport interface CardCvcElementOptions extends BaseIndividualElementOptions {\n    /*\n     * Placeholder\n     */\n    placeholder?: string;\n}\n\nexport interface IbanElementOptions extends BaseElementOptions {\n    /**\n     * Specify the list of countries or country-groups whose IBANs you want to allow.\n     * Must be ['SEPA'].\n     */\n    supportedCountries?: string[];\n\n    /**\n     * Customize the country and format of the placeholder IBAN. Default is DE.\n     */\n    placeholderCountry?: string;\n\n    /**\n     * Appearance of the icon in the Element.\n     */\n    iconStyle?: IconStyle;\n}\n\nexport interface IdealElementOptions extends BaseElementOptions {\n    value?: string;\n\n    /**\n     * Hides the icon in the Element. Default is false.\n     */\n    hideIcon?: boolean;\n}\n\nexport interface ZipCodeElementOptions {\n    containerId: string;\n}\n\nexport enum IconStyle {\n    Solid = 'solid',\n    Default = 'default',\n}\n\nexport interface StripeElementStyle {\n    /**\n     * Base variantall other variants inherit from these styles.\n     */\n    base?: StripeElementStyleVariant;\n\n    /**\n     * Applied when the element has valid input.\n     */\n    complete?: StripeElementStyleVariant;\n\n    /**\n     * Applied when the element has no customer input.\n     */\n    empty?: StripeElementStyleVariant;\n\n    /**\n     * Applied when the element has invalid input.\n     */\n    invalid?: StripeElementStyleVariant;\n}\n\nexport interface StripeElementClasses {\n    /**\n     * The base class applied to the container. Defaults to StripeElement.\n     */\n    base?: string;\n\n    /**\n     * The class name to apply when the Element is complete. Defaults to StripeElement--complete.\n     */\n    complete?: string;\n\n    /**\n     * The class name to apply when the Element is empty. Defaults to StripeElement--empty.\n     */\n    empty?: string;\n\n    /**\n     * The class name to apply when the Element is focused. Defaults to StripeElement--focus.\n     */\n    focus?: string;\n\n    /**\n     * The class name to apply when the Element is invalid. Defaults to StripeElement--invalid.\n     */\n    invalid?: string;\n\n    /**\n     * The class name to apply when the Element has its value autofilled by the browser\n     * (only on Chrome and Safari). Defaults to StripeElement--webkit-autofill.\n     */\n    webkitAutoFill?: string;\n}\n\nexport interface StripeAddress {\n    /**\n     * City, district, suburb, town, or village.\n     */\n    city?: string;\n\n    /**\n     * Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).\n     */\n    country?: string;\n\n    /**\n     * Address line 1 (e.g., street, PO Box, or company name).\n     */\n    line1: string;\n\n    /**\n     * Address line 2 (e.g., apartment, suite, unit, or building).\n     */\n    line2?: string;\n\n    /**\n     * ZIP or postal code.\n     */\n    postal_code?: string;\n\n    /**\n     * State, county, province, or region.\n     */\n    state?: string;\n}\n\nexport interface StripeBillingDetails {\n    /**\n     * Billing address.\n     */\n    address?: StripeAddress;\n\n    /**\n     * Email address.\n     */\n    email?: string;\n\n    /**\n     * Full name.\n     */\n    name?: string;\n\n    /**\n     * Billing phone number (including extension).\n     */\n    phone?: string;\n}\n\nexport interface StripeShippingAddress {\n    /**\n     * Shipping Address\n     */\n    address: StripeAddress;\n\n    /**\n     * Recipient name\n     */\n    name: string;\n\n    /**\n     * The delivery service that shipped a physical product, such as Fedex, UPS, USPS, etc.\n     */\n    carrier?: string;\n\n    /**\n     * Recipient phone (including extension).\n     */\n    phone?: string;\n\n    /**\n     * The tracking number for a physical product, obtained from the delivery service.\n     * If multiple tracking numbers were generated for this purchase, please separate them with commas.\n     */\n    tracking_number?: string;\n}\n\n/**\n * Data to be sent with a `stripe.confirmAlipayPayment` request.\n * Refer to the [Payment Intents API](https://stripe.com/docs/api/payment_intents/confirm) for a full list of parameters.\n */\nexport interface StripeConfirmAlipayPaymentData {\n    /*\n     * If you are [handling next actions yourself](https://stripe.com/docs/payments/payment-intents/verifying-status#next-actions), pass in a return_url. If the subsequent action\n     * is redirect_to_url, this URL will be used on the return path for the redirect.\n     *\n     * @recommended\n     */\n    return_url?: string;\n}\n\n/**\n * Data to be sent with a `stripe.confirmCardPayment` request.\n * Refer to the [Payment Intents API](https://stripe.com/docs/api/payment_intents/confirm) for a full list of parameters.\n */\nexport interface StripeConfirmCardPaymentData {\n    /*\n     * Either the id of an existing [PaymentMethod](https://stripe.com/docs/api/payment_methods), or an object containing data to create a\n     * PaymentMethod with. See the use case sections below for details.\n     *\n     * @recommended\n     */\n    payment_method?: CreatePaymentMethodCardData;\n\n    /*\n     * The [shipping details](https://stripe.com/docs/api/payment_intents/confirm#confirm_payment_intent-shipping) for the payment, if collected.\n     *\n     * @recommended\n     */\n    shipping?: StripeShippingAddress;\n\n    /*\n     * If you are [handling next actions yourself](https://stripe.com/docs/payments/payment-intents/verifying-status#next-actions), pass in a return_url. If the subsequent action\n     * is redirect_to_url, this URL will be used on the return path for the redirect.\n     *\n     * @recommended\n     */\n    return_url?: string;\n\n    /**\n     * Indicates that you intend to make future payments with this PaymentIntent's payment method.\n     *\n     * If present, the payment method used with this PaymentIntent can be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer, even after the transaction completes.\n     *\n     * Use `on_session` if you intend to only reuse the payment method when your customer is present in your checkout flow. Use `off_session` if your customer may or may not be in your checkout flow.\n     */\n    setup_future_usage?: 'off_session' | 'on_session' | null;\n}\n\n/**\n * Data to be sent with a `stripe.confirmIdealPayment` request.\n * Refer to the [Payment Intents API](https://stripe.com/docs/api/payment_intents/confirm) for a full list of parameters.\n */\nexport interface StripeConfirmIdealPaymentData {\n    /*\n     * Either the id of an existing [PaymentMethod](https://stripe.com/docs/api/payment_methods), or an object containing data to create a\n     * PaymentMethod with. See the use case sections below for details.\n     *\n     * @recommended\n     */\n    payment_method?: CreatePaymentMethodIdealData;\n\n    /*\n     * If you are [handling next actions yourself](https://stripe.com/docs/payments/payment-intents/verifying-status#next-actions), pass in a return_url. If the subsequent action\n     * is redirect_to_url, this URL will be used on the return path for the redirect.\n     *\n     * @recommended\n     */\n    return_url?: string;\n}\n\n/**\n * Data to be sent with a `stripe.confirmSEPAPayment` request.\n * Refer to the [Payment Intents API](https://stripe.com/docs/api/payment_intents/confirm) for a full list of parameters.\n */\nexport interface StripeConfirmSepaPaymentData {\n    /*\n     * Either the id of an existing [PaymentMethod](https://stripe.com/docs/api/payment_methods), or an object containing data to create a\n     * PaymentMethod with. See the use case sections below for details.\n     *\n     * @recommended\n     */\n    payment_method?: CreatePaymentMethodSepaData;\n}\n\nexport type StripeConfirmPaymentData =\n    | StripeConfirmAlipayPaymentData\n    | StripeConfirmCardPaymentData\n    | StripeConfirmIdealPaymentData\n    | StripeConfirmSepaPaymentData\n    | undefined;\n\nexport type StripeElementOptions =\n    | CardElementOptions\n    | CardExpiryElementOptions\n    | CardNumberElementOptions\n    | CardCvcElementOptions\n    | IdealElementOptions\n    | IbanElementOptions\n    | ZipCodeElementOptions;\n\nexport interface StripeElement {\n    /**\n     * The `element.mount` method attaches your element to the DOM.\n     */\n    mount(domElement: string | HTMLElement): void;\n\n    /**\n     * Removes the element from the DOM and destroys it.\n     * A destroyed element can not be re-activated or re-mounted to the DOM.\n     */\n    destroy(): void;\n\n    /**\n     * Unmounts the element from the DOM.\n     * Call `element.mount` to re-attach it to the DOM.\n     */\n    unmount(): void;\n}\n\nexport interface StripeElements {\n    /**\n     * Creates a `AlipayElement` | `CardElement` | `CardCvcElement` |`CardExpiryElement` | `CardExpiryElement` | `CardNumberElement` | `IdealBankElement` | `IbanElement`.\n     */\n    create(elementType: StripeElementType, options?: StripeElementOptions): StripeElement;\n\n    /**\n     * Looks up a previously created `Element` by its type.\n     */\n    getElement(elementType: StripeElementType): StripeElement | null;\n}\n\n/**\n * This object is used to pass custom fonts when creating an [Elements](https://stripe.com/docs/js/elements_object/create) object.\n */\nexport interface CssFontSource {\n    /**\n     * A relative or absolute URL pointing to a CSS file with [@font-face](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face) definitions, for example:\n     * `https://fonts.googleapis.com/css?family=Open+Sans`\n     * Note that if you are using a [content security policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) (CSP),\n     * [additional directives](https://stripe.com/docs/security#content-security-policy) may be necessary.\n     */\n    cssSrc: string;\n}\n\n/**\n * This object is used to pass custom fonts when creating an [Elements](https://stripe.com/docs/js/elements_object/create) object.\n */\nexport interface CustomFontSource {\n    /**\n     * The name to give the font.\n     */\n    family: string;\n\n    /**\n     * A valid [src](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src) value pointing to your\n     * custom font file. This is usually (though not always) a link to a file with a .woff , .otf, or .svg suffix.\n     */\n    src: string;\n\n    /**\n     * A valid [font-display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display) value.\n     */\n    display?: string;\n\n    /**\n     * One of normal, italic, oblique. Defaults to normal.\n     */\n    style?: string;\n\n    /**\n     * A valid [unicode-range](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range) value.\n     */\n    unicodeRange?: string;\n\n    /**\n     * A valid [font-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight). Note that this is a string, not a number.\n     */\n    weight?: string;\n}\n\nexport type CustomFont = CssFontSource | CustomFontSource;\n\nexport interface StripeElementsOptions {\n    /**\n     * An array of custom fonts, which elements created from the Elements object can use.\n     * Fonts can be specified as [CssFontSource](https://stripe.com/docs/js/appendix/css_font_source_object)\n     * or [CustomFontSource](https://stripe.com/docs/js/appendix/custom_font_source_object) objects.\n     */\n    fonts?: CustomFont[];\n\n    /**\n     * A [locale](https://stripe.com/docs/js/appendix/supported_locales) to display placeholders and\n     * error strings in. Default is auto (Stripe detects the locale of the browser).\n     * Setting the locale does not affect the behavior of postal code validationa valid postal code\n     * for the billing country of the card is still required.\n     */\n    locale?: string;\n}\n\nexport interface StripeConfirmPaymentOptions {\n    /**\n     * Set this to false if you want to [manually handle the authorization redirect](https://stripe.com/docs/payments/ideal#handle-redirect). Default is true.\n     */\n    handleActions?: boolean;\n}\n\nexport interface StripeV3Client {\n    /**\n     * Create an `Elements` instance, which manages a group of elements.\n     */\n    elements(options?: StripeElementsOptions): StripeElements;\n\n    /*\n     * @docs https://stripe.com/docs/js/payment_intents/confirm_alipay_payment\n     *\n     * Use `stripe.confirmAlipayPayment` in the Alipay payment method creation flow when the customer submits your payment form.\n     * When called, it will confirm the [PaymentIntent](https://stripe.com/docs/api/payment_intents) with data you provide, and it will automatically\n     * redirect the customer to the authorize the transaction. Once authorization is complete, the customer will be redirected\n     * back to your specified `return_url`. When you confirm a `PaymentIntent`, it needs to have an attached [PaymentMethod](https://stripe.com/docs/api/payment_methods).\n     * In addition to confirming the `PaymentIntent`, this method can automatically create and attach a new `PaymentMethod` for you.\n     * If you have already attached a `PaymentMethod` you can call this method without needing to provide any additional data.\n     * These use cases are detailed in the sections that follow.\n     *\n     * @returns\n     * `stripe.confirmAlipayPayment` by default, will trigger a redirect when successful. If there is an error, or when handling\n     * `next_actions` manually by using the `handleActions: false` option, it will return a `Promise` which resolves with a `result` object.\n     * This object has either:\n     *\n     * - result.paymentIntent: the successful PaymentIntent.\n     * - result.error: an error. Refer to the API reference for all possible errors.\n     *\n     * Note that `stripe.confirmAlipayPayment` may take several seconds to complete. During that time, you should disable your\n     * form from being resubmitted and show a waiting indicator like a spinner. If you receive an error result, you should\n     * be sure to show that error to the customer, re-enable the form, and hide the waiting indicator.\n     */\n    confirmAlipayPayment(\n        /**\n         * The [client secret](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-client_secret) of the PaymentIntent.\n         */\n        clientSecret: string,\n\n        /**\n         * Data to be sent with the request. Refer to the Payment Intents API for a full list of parameters.\n         */\n        data?: StripeConfirmAlipayPaymentData,\n\n        /**\n         * An options object to control the behavior of this method.\n         */\n        options?: StripeConfirmPaymentOptions,\n    ): Promise<{ paymentIntent?: PaymentIntent; error?: StripeError }>;\n\n    /*\n     * @docs https://stripe.com/docs/js/payment_intents/confirm_card_payment\n     *\n     * Use `stripe.confirmCardPayment` when the customer submits your payment form.\n     * When called, it will confirm the [PaymentIntent](https://stripe.com/docs/api/payment_intents)\n     * with `data` you provide and carry out 3DS or other next actions if they are required.\n     *\n     * If you are using [Dynamic 3D Secure](https://stripe.com/docs/payments/3d-secure#three-ds-radar), `stripe.confirmCardPayment` will\n     * trigger your Radar rules to execute and may open a dialog for your customer to authenticate their payment.\n     *\n     * When you confirm a `PaymentIntent`, it needs to have an attached [PaymentMethod](https://stripe.com/docs/api/payment_methods).\n     * In addition to confirming the `PaymentIntent`, this method can automatically create and attach a new `PaymentMethod` for you.\n     * It can also be called with an existing `PaymentMethod`, or if you have already attached a PaymentMethod you can call this\n     * method without needing to provide any additional data. These use cases are detailed in the sections that follow.\n     *\n     * @returns\n     * `stripe.confirmCardPayment` will return a Promise which resolves with a result object.\n     * This object has either:\n     *\n     * - result.paymentIntent: the successful PaymentIntent.\n     * - result.error: an error. Refer to the API reference for all possible errors.\n     *\n     * Note that stripe.confirmCardPayment may take several seconds to complete. During that time, you should disable\n     * your form from being resubmitted and show a waiting indicator like a spinner. If you receive an error result,\n     * you should be sure to show that error to the customer, re-enable the form, and hide the waiting indicator.\n     *\n     * Additionally, `stripe.confirmCardPayment may trigger` a [3D Secure](https://stripe.com/docs/payments/3d-secure) authentication\n     * challenge. This will be shown in a modal dialog and may be confusing for customers using assistive technologies like\n     * screen readers. You should make your form accessible by ensuring that success or error messages are clearly read out\n     * after this method completes.\n     *\n     */\n    confirmCardPayment(\n        /**\n         * The [client secret](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-client_secret) of the PaymentIntent.\n         */\n        clientSecret: string,\n\n        /**\n         * Data to be sent with the request. Refer to the Payment Intents API for a full list of parameters.\n         */\n        data?: StripeConfirmCardPaymentData,\n\n        /**\n         * An options object to control the behavior of this method.\n         */\n        options?: StripeConfirmPaymentOptions,\n    ): Promise<{ paymentIntent?: PaymentIntent; error?: StripeError }>;\n\n    /*\n     * @docs https://stripe.com/docs/js/payment_intents/confirm_ideal_payment\n     *\n     * Use `stripe.confirmIdealPayment` in the [iDEAL Payments with Payment Methods](https://stripe.com/docs/payments/ideal)\n     * flow when the customer submits your payment form. When called, it will confirm the `PaymentIntent` with `data` you\n     * provide, and it will automatically redirect the customer to the authorize the transaction.\n     * Once authorization is complete, the customer will be redirected back to your specified `return_url`.\n     *\n     * When you confirm a `PaymentIntent`, it needs to have an attached [PaymentMethod](https://stripe.com/docs/api/payment_methods).\n     * In addition to confirming the `PaymentIntent`, this method can automatically create and attach a new `PaymentMethod` for you.\n     * It can also be called with an existing `PaymentMethod`, or if you have already attached a PaymentMethod you can call this\n     * method without needing to provide any additional data. These use cases are detailed in the sections that follow.\n     *\n     * @returns\n     * By default, `stripe.confirmIdealPayment` will trigger a redirect when successful. If there is an error, or when handling\n     * next actions manually by using the `handleActions: false` option, it will return a `Promise` which resolves with a `result`\n     * object. This object has either:\n     *\n     * - result.paymentIntent: the successful PaymentIntent.\n     * - result.error: an error. Refer to the API reference for all possible errors.\n     *\n     * Note that `stripe.confirmIdealPayment` may take several seconds to complete. During that time, you should disable\n     * your form from being resubmitted and show a waiting indicator like a spinner. If you receive an error result,\n     * you should be sure to show that error to the customer, re-enable the form, and hide the waiting indicator.\n     */\n    confirmIdealPayment(\n        /**\n         * The [client secret](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-client_secret) of the PaymentIntent.\n         */\n        clientSecret: string,\n\n        /**\n         * Data to be sent with the request. Refer to the Payment Intents API for a full list of parameters.\n         */\n        data?: StripeConfirmIdealPaymentData,\n\n        /**\n         * An options object to control the behavior of this method.\n         */\n        options?: StripeConfirmPaymentOptions,\n    ): Promise<{ paymentIntent?: PaymentIntent; error?: StripeError }>;\n\n    /*\n     *\n     * Use `stripe.confirmSepaDebitPayment` in the [SEPA Direct Debit Payments](https://stripe.com/docs/payments/sepa-debit)\n     * with Payment Methods flow when the customer submits your payment form. When called, it will confirm the\n     * [PaymentIntent](https://stripe.com/docs/api/payment_intents) with `data` you provide. Note that there are some additional\n     * requirements to this flow that are not covered in this reference. Refer to our [integration guide](https://stripe.com/docs/payments/sepa-debit\n     * for more details.\n     *\n     * When you confirm a PaymentIntent, it needs to have an attached PaymentMethod. In addition to confirming the PaymentIntent,\n     * this method can automatically create and attach a new PaymentMethod for you. If you have already attached a\n     * [PaymentMethod](https://stripe.com/docs/api/payment_methods) you can call this method without needing to provide any additional data.\n     * These use cases are detailed in the sections that follow.\n     *\n     * @docs https://stripe.com/docs/js/payment_intents/confirm_sepa_debit_payment\n     */\n    confirmSepaDebitPayment(\n        /**\n         * The [client secret](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-client_secret) of the PaymentIntent.\n         */\n        clientSecret: string,\n\n        /**\n         * Data to be sent with the request. Refer to the [Payment Intents API](https://stripe.com/docs/api/payment_intents/confirm) for a full list of parameters.\n         */\n        data?: StripeConfirmSepaPaymentData,\n    ): Promise<{ paymentIntent?: PaymentIntent; error?: StripeError }>;\n\n    /*\n     * Use stripe.createPaymentMethod to convert payment information collected by elements into a PaymentMethod\n     * object that you safely pass to your server to use in an API call.\n     *\n     * @docs https://stripe.com/docs/js/payment_methods/create_payment_method\n     *\n     * @param type: String, The type of the PaymentMethod to create. Refer to the PaymentMethod API for all possible values.\n     * @param card: StripeElement, A card or cardNumber Element.\n     * @param billing_details: StripeBillingDetails, Billing information associated with the PaymentMethod that\n     * may be used or required by particular types of payment methods.\n     */\n    createPaymentMethod(\n        params: CreatePaymentMethodParams,\n    ): Promise<{ paymentMethod?: PaymentMethod; error?: StripeError }>;\n\n    /*\n     * Use stripe.handleCardAction in the Payment Intents API manual confirmation flow to handle a PaymentIntent\n     * with the requires_action status. It will throw an error if the PaymentIntent has a different status.\n     *\n     * @docs https://stripe.com/docs/js/payment_intents/handle_card_action\n     *\n     * @param paymentIntentClientSecret: String, The client secret of the PaymentIntent to handle.\n     */\n    handleCardAction(\n        paymentIntentClientSecret: string,\n    ): Promise<{ paymentIntent?: PaymentIntent; error?: StripeError }>;\n}\n\nexport interface CreatePaymentMethodParams {\n    type: StripePaymentMethodType;\n    card: StripeElement;\n    billing_details?: StripeBillingDetails;\n    allow_redisplay?: 'always' | 'limited' | 'unspecified';\n}\n\nexport interface StripeHostWindow extends Window {\n    Stripe?(stripePublishableKey: string, options?: StripeConfigurationOptions): StripeV3Client;\n}\n\nexport enum StripeElementType {\n    Alipay = 'alipay',\n    CardCvc = 'cardCvc',\n    CardExpiry = 'cardExpiry',\n    CardNumber = 'cardNumber',\n    CreditCard = 'card',\n    IDEAL = 'idealBank',\n    Sepa = 'iban',\n}\n\nexport enum StripePaymentMethodType {\n    Alipay = 'alipay',\n    CreditCard = 'card',\n    IDEAL = 'ideal',\n    Sepa = 'sepa_debit',\n}\n\n/**\n * Initialization options.\n */\nexport interface StripeConfigurationOptions {\n    /**\n     * For usage with [Connect](https://stripe.com/docs/connect) only.\n     * Specifying a connected account ID (e.g., acct_24BFMpJ1svR5A89k) allows you to perform actions on behalf of that account.\n     */\n    stripeAccount: string;\n\n    /**\n     * Override your account's [API version](https://stripe.com/docs/api/versioning)\n     */\n    apiVersion?: string;\n\n    /**\n     * A locale used to globally configure localization in Stripe. Setting the locale here will localize error strings for all Stripe.js methods. It will also configure the locale for Elements and Checkout. Default is auto (Stripe detects the locale of the browser).\n     * Note that Checkout supports a slightly different set of locales than Stripe.js.\n     */\n    locale?: string;\n\n    betas?: string[];\n}\n\nexport interface StripeAdditionalActionData {\n    redirect_url?: string;\n    intent?: string;\n}\n\nexport interface StripeAdditionalAction {\n    type: string;\n    data: StripeAdditionalActionData;\n}\n\nexport interface StripeCardElements {\n    [index: number]: StripeElement;\n}\n\nexport interface IndividualCardElementOptions {\n    cardCvcElementOptions: CardCvcElementOptions;\n    cardExpiryElementOptions: CardExpiryElementOptions;\n    cardNumberElementOptions: CardNumberElementOptions;\n    zipCodeElementOptions?: ZipCodeElementOptions;\n}\n\nexport interface StripeV3PaymentMethod extends PaymentMethod {\n    initializationData: StripeV3InitializationData;\n}\n\nexport interface StripeV3InitializationData {\n    stripePublishableKey: string;\n    stripeConnectedAccount: string;\n    useIndividualCardFields: boolean;\n    allowRedisplayForStoredInstruments?: boolean;\n}\n","import { StandardError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nexport enum StripeV3ErrorType {\n    AuthFailure = 'auth_failure',\n}\n\nexport default class StripeV3Error extends StandardError {\n    subtype: string;\n\n    constructor(subtype: StripeV3ErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.type = 'stripev3_error';\n        this.subtype = subtype;\n    }\n}\n\nfunction getErrorMessage(type: StripeV3ErrorType) {\n    switch (type) {\n        case StripeV3ErrorType.AuthFailure:\n            return `User did not authenticate`;\n\n        default:\n            return 'There was an error while processing your payment. Please try again or contact us.';\n    }\n}\n","import { includes, isEmpty, omitBy, some } from 'lodash';\n\nimport {\n    Address,\n    BillingAddress,\n    Customer,\n    HostedForm,\n    HostedFormOptions,\n    InvalidArgumentError,\n    isBillingAddressLike,\n    isHostedInstrumentLike,\n    isRequestError,\n    isVaultedInstrument,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderPaymentRequestBody,\n    OrderRequestBody,\n    Payment,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentMethod,\n    PaymentMethodCancelledError,\n    PaymentRequestOptions,\n    PaymentStrategy,\n    StripeV3FormattedPayload,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport isIndividualCardElementOptions from './is-individual-card-element-options';\nimport {\n    PaymentIntent,\n    StripeAdditionalAction,\n    StripeAddress,\n    StripeBillingDetails,\n    StripeCardElements,\n    StripeConfirmIdealPaymentData,\n    StripeConfirmPaymentData,\n    StripeConfirmSepaPaymentData,\n    StripeElement,\n    StripeElementOptions,\n    StripeElements,\n    StripeElementType,\n    StripeError,\n    PaymentMethod as StripePaymentMethod,\n    StripePaymentMethodType,\n    StripeV3Client,\n    StripeV3PaymentMethod,\n} from './stripev3';\nimport StripeV3Error, { StripeV3ErrorType } from './stripev3-error';\nimport StripeV3PaymentInitializeOptions, {\n    WithStripeV3PaymentInitializeOptions,\n} from './stripev3-initialize-options';\nimport StripeV3ScriptLoader from './stripev3-script-loader';\n\nconst APM_REDIRECT = [StripeElementType.Alipay, StripeElementType.IDEAL];\n\nexport default class StripeV3PaymentStrategy implements PaymentStrategy {\n    private initializeOptions?: StripeV3PaymentInitializeOptions;\n    private stripeV3Client?: StripeV3Client;\n    private stripeElements?: StripeElements;\n    private stripeElement?: StripeElement;\n    private stripeCardElements?: StripeCardElements;\n    private useIndividualCardFields?: boolean;\n    private hostedForm?: HostedForm;\n    private isDeinitialize?: boolean;\n    private _allowRedisplayForStoredInstruments?: boolean;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeV3ScriptLoader,\n    ) {}\n\n    async initialize(options: PaymentInitializeOptions & WithStripeV3PaymentInitializeOptions) {\n        const { stripev3, methodId, gatewayId } = options;\n\n        if (!gatewayId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"gatewayId\" argument is not provided.',\n            );\n        }\n\n        this.initializeOptions = stripev3;\n        this.isDeinitialize = false;\n\n        const paymentMethod = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow(methodId);\n\n        const {\n            initializationData: {\n                stripePublishableKey,\n                stripeConnectedAccount,\n                useIndividualCardFields,\n                allowRedisplayForStoredInstruments,\n            },\n        } = paymentMethod as StripeV3PaymentMethod;\n\n        this._allowRedisplayForStoredInstruments = allowRedisplayForStoredInstruments;\n\n        const form = this.getInitializeOptions().form;\n\n        this.useIndividualCardFields = useIndividualCardFields;\n        this.stripeV3Client = await this.loadStripeJs(stripePublishableKey, stripeConnectedAccount);\n\n        if (\n            this.isCreditCard(methodId) &&\n            this.shouldShowTSVHostedForm(methodId, gatewayId) &&\n            form\n        ) {\n            this.hostedForm = await this.mountCardVerificationFields(form);\n        } else {\n            this.stripeElement = await this.mountCardFields(methodId);\n        }\n    }\n\n    async execute(orderRequest: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        const { payment, ...order } = orderRequest;\n\n        let formattedPayload: StripeV3FormattedPayload;\n        let stripeError: StripeError | undefined;\n\n        if (!payment || !payment.paymentData) {\n            throw new PaymentArgumentInvalidError(['payment.paymentData']);\n        }\n\n        const { paymentData, gatewayId, methodId } = payment;\n\n        const { shouldSaveInstrument, shouldSetAsDefaultInstrument } = isHostedInstrumentLike(\n            paymentData,\n        )\n            ? paymentData\n            : { shouldSaveInstrument: false, shouldSetAsDefaultInstrument: false };\n\n        const shouldSubmitOrderBeforeLoadingAPM = includes(APM_REDIRECT, methodId);\n\n        const { isStoreCreditApplied: useStoreCredit } = this.paymentIntegrationService\n            .getState()\n            .getCheckoutOrThrow();\n\n        if (useStoreCredit) {\n            await this.paymentIntegrationService.applyStoreCredit(useStoreCredit);\n        }\n\n        try {\n            if (shouldSubmitOrderBeforeLoadingAPM) {\n                await this.paymentIntegrationService.submitOrder(order, options);\n            }\n\n            if (gatewayId) {\n                await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n                    params: { method: methodId },\n                });\n            }\n\n            const state = this.paymentIntegrationService.getState();\n\n            if (isVaultedInstrument(paymentData)) {\n                await this.paymentIntegrationService.submitOrder(order, options);\n\n                const { instrumentId } = paymentData;\n                const paymentMethod = state.getPaymentMethodOrThrow(payment.methodId);\n                const clientToken = paymentMethod.clientToken;\n\n                if (!clientToken) {\n                    throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n                }\n\n                return await this.executeWithVaulted(\n                    payment,\n                    instrumentId,\n                    shouldSetAsDefaultInstrument,\n                    clientToken,\n                );\n            }\n\n            const paymentMethod = state.getPaymentMethodOrThrow(methodId);\n            const result = await this.confirmStripePayment(paymentMethod);\n            const { clientToken, method } = paymentMethod;\n            const { id: token } = result.paymentIntent ?? result.paymentMethod ?? { id: '' };\n\n            stripeError = result.error;\n\n            formattedPayload = {\n                credit_card_token: { token },\n                vault_payment_instrument: shouldSaveInstrument,\n                confirm: false,\n                set_as_default_stored_instrument: shouldSetAsDefaultInstrument,\n            };\n\n            if (method === StripeElementType.CreditCard) {\n                formattedPayload.client_token = clientToken;\n            }\n\n            if (!shouldSubmitOrderBeforeLoadingAPM) {\n                await this.paymentIntegrationService.submitOrder(order, options);\n            }\n\n            const paymentPayload = this.buildPaymentPayload(\n                methodId,\n                formattedPayload,\n                shouldSetAsDefaultInstrument,\n            );\n\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            await this.processAdditionalAction(\n                this.handleEmptyPaymentIntentError(error, stripeError),\n                methodId,\n                shouldSaveInstrument,\n                shouldSetAsDefaultInstrument,\n            );\n        }\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    deinitialize(): Promise<void> {\n        if (this.hostedForm) {\n            this.hostedForm.detach();\n        }\n\n        this.isDeinitialize = true;\n        this.unmountElement();\n\n        return Promise.resolve();\n    }\n\n    private buildPaymentPayload(\n        methodId: string,\n        formattedPayload: StripeV3FormattedPayload,\n        shouldSetAsDefaultInstrument: boolean | undefined,\n    ): Payment {\n        const paymentData = shouldSetAsDefaultInstrument\n            ? {\n                  formattedPayload: {\n                      ...formattedPayload,\n                      set_as_default_stored_instrument: shouldSetAsDefaultInstrument,\n                  },\n              }\n            : { formattedPayload };\n\n        return { methodId, paymentData };\n    }\n\n    private isCancellationError(stripeError: StripeError | undefined) {\n        return (\n            stripeError &&\n            stripeError.payment_intent.last_payment_error?.message?.indexOf('canceled') !== -1\n        );\n    }\n\n    private isAuthError(stripeError: StripeError | undefined) {\n        return stripeError?.code === 'payment_intent_authentication_failure';\n    }\n\n    private isCreditCard(methodId: string): boolean {\n        return methodId === StripePaymentMethodType.CreditCard;\n    }\n\n    private isHostedFieldAvailable(): boolean {\n        const options = this.getInitializeOptions();\n        const definedFields = omitBy(options.form?.fields, isEmpty);\n\n        return !isEmpty(definedFields);\n    }\n\n    private isHostedPaymentFormEnabled(methodId: string, gatewayId?: string): boolean {\n        const { getPaymentMethodOrThrow } = this.paymentIntegrationService.getState();\n        const paymentMethod = getPaymentMethodOrThrow(methodId, gatewayId);\n\n        return Boolean(paymentMethod.config.isHostedFormEnabled);\n    }\n\n    private async confirmStripePayment(paymentMethod: PaymentMethod): Promise<{\n        paymentIntent?: PaymentIntent | undefined;\n        paymentMethod?: StripePaymentMethod | undefined;\n        error?: StripeError | undefined;\n    }> {\n        const { clientToken: clientSecret, method, returnUrl } = paymentMethod;\n\n        if (!clientSecret) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        switch (method) {\n            case StripeElementType.Alipay:\n                return this.getStripeJs().confirmAlipayPayment(\n                    clientSecret,\n                    { return_url: returnUrl },\n                    { handleActions: false },\n                );\n\n            case StripeElementType.IDEAL: {\n                const data = this.mapStripePaymentData(StripePaymentMethodType.IDEAL, returnUrl);\n\n                return this.getStripeJs().confirmIdealPayment(clientSecret, data, {\n                    handleActions: false,\n                });\n            }\n\n            case StripeElementType.Sepa: {\n                const data = this.mapStripePaymentData(StripePaymentMethodType.Sepa);\n\n                return this.getStripeJs().confirmSepaDebitPayment(clientSecret, data);\n            }\n\n            default: {\n                const card = this.useIndividualCardFields\n                    ? this.getStripeCardElements()[0]\n                    : this.getStripeElement();\n                const billingDetails = this.mapStripeBillingDetails(\n                    this.paymentIntegrationService.getState().getBillingAddress(),\n                    this.paymentIntegrationService.getState().getCustomer(),\n                );\n                const shouldAllowRedisplay = this._allowRedisplayForStoredInstruments;\n\n                return this.getStripeJs().createPaymentMethod({\n                    type: StripePaymentMethodType.CreditCard,\n                    card,\n                    billing_details: billingDetails,\n                    ...(shouldAllowRedisplay ? { allow_redisplay: 'always' } : {}),\n                });\n            }\n        }\n    }\n\n    private async executeWithVaulted(\n        payment: OrderPaymentRequestBody,\n        token: string,\n        shouldSetAsDefaultInstrument: boolean | undefined,\n        clientToken: string,\n    ): Promise<any> {\n        const formattedPayload = {\n            bigpay_token: { token },\n            confirm: true,\n            client_token: clientToken,\n            set_as_default_stored_instrument: shouldSetAsDefaultInstrument,\n        };\n\n        if (\n            this.isHostedPaymentFormEnabled(payment.methodId, payment.gatewayId) &&\n            this.hostedForm\n        ) {\n            const form = this.hostedForm;\n\n            if (payment.paymentData && isVaultedInstrument(payment.paymentData)) {\n                payment.paymentData = {\n                    ...payment.paymentData,\n                    instrumentId: JSON.stringify({\n                        token: payment.paymentData?.instrumentId || '',\n                        client_token: clientToken,\n                    }),\n                };\n            }\n\n            await form.validate();\n            await form.submit(payment);\n\n            return this.paymentIntegrationService.loadCurrentOrder();\n        }\n\n        const paymentPayload = this.buildPaymentPayload(\n            payment.methodId,\n            formattedPayload,\n            shouldSetAsDefaultInstrument,\n        );\n\n        return this.paymentIntegrationService.submitPayment(paymentPayload);\n    }\n\n    private getInitializeOptions(): StripeV3PaymentInitializeOptions {\n        if (!this.initializeOptions) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.initializeOptions;\n    }\n\n    private getStripeCardElements(): StripeCardElements {\n        if (!this.stripeCardElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.stripeCardElements;\n    }\n\n    private getStripeElement(): StripeElement {\n        if (!this.stripeElement) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.stripeElement;\n    }\n\n    private getStripeJs(): StripeV3Client {\n        if (!this.stripeV3Client) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.stripeV3Client;\n    }\n\n    private handleEmptyPaymentIntentError(error: unknown, stripeError: StripeError | undefined) {\n        if (!isRequestError(error)) {\n            return error;\n        }\n\n        return some(error.body.errors, { code: 'required_field' }) && stripeError\n            ? new Error(stripeError.message)\n            : error;\n    }\n\n    private async loadStripeJs(\n        stripePublishableKey: string,\n        stripeConnectedAccount: string,\n    ): Promise<StripeV3Client> {\n        if (this.stripeV3Client) {\n            return Promise.resolve(this.stripeV3Client);\n        }\n\n        return this.scriptLoader.load(\n            stripePublishableKey,\n            stripeConnectedAccount,\n            this.paymentIntegrationService.getState().getLocale(),\n        );\n    }\n\n    private mapStripeAddress(address?: Address): StripeAddress {\n        if (address) {\n            const {\n                city,\n                countryCode: country,\n                address1: line1,\n                address2: line2,\n                postalCode,\n                stateOrProvinceCode: state,\n            } = address;\n\n            return { city, country, line1, line2, postal_code: postalCode, state };\n        }\n\n        return { line1: '' };\n    }\n\n    private mapStripeBillingDetails(\n        billingAddress?: BillingAddress,\n        customer?: Customer,\n    ): StripeBillingDetails {\n        const { firstName, lastName } = billingAddress ||\n            customer || { firstName: 'Guest', lastName: '' };\n        const name = `${firstName} ${lastName}`.trim();\n        const { options } = this.getInitializeOptions();\n\n        if (this.useIndividualCardFields && isIndividualCardElementOptions(options)) {\n            const { zipCodeElementOptions } = options;\n\n            if (zipCodeElementOptions) {\n                const postalCode = document.getElementById(zipCodeElementOptions.containerId)\n                    ? (\n                          document.getElementById(\n                              zipCodeElementOptions.containerId,\n                          ) as HTMLInputElement\n                      ).value\n                    : '';\n\n                if (postalCode && billingAddress) {\n                    billingAddress = { ...billingAddress, postalCode };\n                }\n            }\n        }\n\n        const address = {\n            address: this.mapStripeAddress(billingAddress),\n        };\n\n        if (customer && customer.addresses[0] && isBillingAddressLike(customer.addresses[0])) {\n            const customerAddress = customer.addresses[0];\n            const { email } = customer;\n            const { phone } = customerAddress;\n\n            return phone ? { ...address, email, name, phone } : { ...address, email, name };\n        }\n\n        if (billingAddress) {\n            const { email, phone } = billingAddress;\n\n            return phone ? { ...address, email, name, phone } : { ...address, email, name };\n        }\n\n        return { ...address, name };\n    }\n\n    private mapStripePaymentData(\n        stripePaymentMethodType: StripePaymentMethodType.IDEAL,\n        returnUrl?: string,\n    ): StripeConfirmIdealPaymentData;\n    private mapStripePaymentData(\n        stripePaymentMethodType: StripePaymentMethodType.Sepa,\n    ): StripeConfirmSepaPaymentData;\n    private mapStripePaymentData(\n        stripePaymentMethodType: StripePaymentMethodType,\n        returnUrl?: string,\n    ): StripeConfirmPaymentData {\n        const customer = this.paymentIntegrationService.getState().getCustomer();\n        const billingAddress = this.paymentIntegrationService.getState().getBillingAddress();\n\n        const result: Partial<StripeConfirmPaymentData> = {\n            payment_method: {\n                [stripePaymentMethodType]: this.getStripeElement(),\n                billing_details: this.mapStripeBillingDetails(billingAddress, customer),\n            },\n        };\n\n        if (stripePaymentMethodType === StripePaymentMethodType.IDEAL) {\n            return { ...result, return_url: returnUrl };\n        }\n\n        return result;\n    }\n\n    private mountCardFields(methodId: string): Promise<StripeElement> {\n        const { options, containerId } = this.getInitializeOptions();\n\n        let stripeElement: StripeElement;\n\n        return new Promise((resolve, reject) => {\n            if (!this.stripeElements) {\n                this.stripeElements = this.getStripeJs().elements();\n            }\n\n            switch (methodId) {\n                case StripeElementType.CreditCard:\n                    if (this.useIndividualCardFields && isIndividualCardElementOptions(options)) {\n                        const {\n                            cardNumberElementOptions,\n                            cardExpiryElementOptions,\n                            cardCvcElementOptions,\n                        } = options;\n\n                        const cardNumberElement =\n                            this.stripeElements.getElement(StripeElementType.CardNumber) ||\n                            this.stripeElements.create(\n                                StripeElementType.CardNumber,\n                                cardNumberElementOptions,\n                            );\n                        const cardExpiryElement =\n                            this.stripeElements.getElement(StripeElementType.CardExpiry) ||\n                            this.stripeElements.create(\n                                StripeElementType.CardExpiry,\n                                cardExpiryElementOptions,\n                            );\n                        const cardCvcElement =\n                            this.stripeElements.getElement(StripeElementType.CardCvc) ||\n                            this.stripeElements.create(\n                                StripeElementType.CardCvc,\n                                cardCvcElementOptions,\n                            );\n\n                        this.stripeCardElements = [\n                            cardNumberElement,\n                            cardExpiryElement,\n                            cardCvcElement,\n                        ];\n                        stripeElement = this.stripeCardElements[0];\n\n                        try {\n                            cardNumberElement.mount(`#${cardNumberElementOptions.containerId}`);\n                            cardExpiryElement.mount(`#${cardExpiryElementOptions.containerId}`);\n                            cardCvcElement.mount(`#${cardCvcElementOptions.containerId}`);\n                        } catch (error) {\n                            if (!this.isDeinitialize) {\n                                reject(\n                                    new InvalidArgumentError(\n                                        'Unable to mount Stripe component without valid container ID.',\n                                    ),\n                                );\n                            }\n                        }\n                    } else {\n                        stripeElement =\n                            this.stripeElements.getElement(methodId) ||\n                            this.stripeElements.create(methodId, options as StripeElementOptions);\n\n                        try {\n                            stripeElement.mount(`#${containerId}`);\n                        } catch (error) {\n                            if (!this.isDeinitialize) {\n                                reject(\n                                    new InvalidArgumentError(\n                                        'Unable to mount Stripe component without valid container ID.',\n                                    ),\n                                );\n                            }\n                        }\n                    }\n\n                    break;\n\n                case StripeElementType.IDEAL:\n                case StripeElementType.Sepa:\n                    stripeElement =\n                        this.stripeElements.getElement(methodId) ||\n                        this.stripeElements.create(methodId, options as StripeElementOptions);\n\n                    try {\n                        stripeElement.mount(`#${containerId}`);\n                    } catch (error) {\n                        if (!this.isDeinitialize) {\n                            reject(\n                                new InvalidArgumentError(\n                                    'Unable to mount Stripe component without valid container ID.',\n                                ),\n                            );\n                        }\n                    }\n\n                    break;\n\n                case StripeElementType.Alipay:\n                    break;\n            }\n\n            resolve(stripeElement);\n        });\n    }\n\n    private async mountCardVerificationFields(formOptions: HostedFormOptions): Promise<HostedForm> {\n        const state = this.paymentIntegrationService.getState();\n        const storeConfig = state.getStoreConfig();\n\n        if (!storeConfig) {\n            throw new MissingDataError(MissingDataErrorType.MissingCheckoutConfig);\n        }\n\n        const bigpayBaseUrl = storeConfig.paymentSettings.bigpayBaseUrl;\n\n        const form = this.paymentIntegrationService.createHostedForm(bigpayBaseUrl, formOptions);\n\n        await form.attach();\n\n        return form;\n    }\n\n    private async processAdditionalAction(\n        error: unknown,\n        methodId: string,\n        shouldSaveInstrument = false,\n        shouldSetAsDefaultInstrument = false,\n    ): Promise<any | never> {\n        if (!isRequestError(error)) {\n            throw error;\n        }\n\n        const isAdditionalActionError = some(error.body.errors, {\n            code: 'additional_action_required',\n        });\n        const isThreeDSecureRequiredError = some(error.body.errors, {\n            code: 'three_d_secure_required',\n        });\n\n        if (isAdditionalActionError) {\n            const action: StripeAdditionalAction = error.body.additional_action_required;\n\n            if (action && action.type === 'redirect_to_url') {\n                return new Promise(() => {\n                    if (action.data.redirect_url) {\n                        window.location.replace(action.data.redirect_url);\n                    }\n                });\n            }\n        }\n\n        if (isThreeDSecureRequiredError) {\n            const clientSecret = error.body.three_ds_result.token;\n            const needsConfirm = false;\n            let catchedConfirmError = false;\n            let result;\n\n            try {\n                result = await this.getStripeJs().confirmCardPayment(clientSecret);\n            } catch (error) {\n                catchedConfirmError = true;\n            }\n\n            if (result?.error) {\n                if (this.isCancellationError(result.error)) {\n                    throw new PaymentMethodCancelledError();\n                }\n\n                if (this.isAuthError(result.error)) {\n                    throw new StripeV3Error(StripeV3ErrorType.AuthFailure);\n                }\n\n                throw new Error(result.error.message);\n            }\n\n            const token = this.getPaymentToken(\n                result?.paymentIntent,\n                clientSecret,\n                catchedConfirmError,\n            );\n\n            const formattedPayload = {\n                credit_card_token: { token },\n                vault_payment_instrument: shouldSaveInstrument,\n                confirm: needsConfirm,\n            };\n\n            const paymentPayload = this.buildPaymentPayload(\n                methodId,\n                formattedPayload,\n                shouldSetAsDefaultInstrument,\n            );\n\n            try {\n                return await this.paymentIntegrationService.submitPayment(paymentPayload);\n            } catch (error) {\n                throw this.handleEmptyPaymentIntentError(error, result?.error);\n            }\n        }\n\n        throw error;\n    }\n\n    private getPaymentToken(\n        paymentIntent: PaymentIntent | undefined,\n        clientSecret: string,\n        catchedConfirmError: boolean,\n    ): string {\n        if (!paymentIntent || catchedConfirmError) {\n            return clientSecret;\n        }\n\n        return paymentIntent.id;\n    }\n\n    private shouldShowTSVHostedForm(methodId: string, gatewayId: string): boolean {\n        return (\n            this.isHostedFieldAvailable() && this.isHostedPaymentFormEnabled(methodId, gatewayId)\n        );\n    }\n\n    private unmountElement(): void {\n        if (this.stripeElement) {\n            this.stripeElement.unmount();\n            this.stripeElement = undefined;\n        }\n    }\n}\n","import BillingAddress from './billing-address';\n\nexport default function isBillingAddressLike(address: any): address is BillingAddress {\n    return (\n        typeof address === 'object' &&\n        address !== null &&\n        'id' in address &&\n        typeof address.id !== 'undefined'\n    );\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the client library of a payment method fails\n * to load, or for some reason, it is inaccessible.\n */\nexport default class PaymentMethodClientUnavailableError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method is not loaded or ready to be used.',\n        );\n\n        this.name = 'PaymentMethodClientUnavailableError';\n        this.type = 'payment_method_client_unavailable';\n    }\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport { PaymentMethodClientUnavailableError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { StripeHostWindow, StripeV3Client } from './stripev3';\n\nexport default class StripeV3ScriptLoader {\n    constructor(\n        private scriptLoader: ScriptLoader,\n        private stripeWindow: StripeHostWindow = window,\n    ) {}\n\n    load(\n        stripePublishableKey: string,\n        stripeAccount: string,\n        locale?: string,\n    ): Promise<StripeV3Client> {\n        return this.scriptLoader.loadScript('https://js.stripe.com/v3/').then(() => {\n            if (!this.stripeWindow.Stripe) {\n                throw new PaymentMethodClientUnavailableError();\n            }\n\n            return this.stripeWindow.Stripe(stripePublishableKey, {\n                stripeAccount,\n                locale,\n                betas: ['payment_intent_beta_3', 'alipay_pm_beta_1'],\n                apiVersion: '2020-03-02;alipay_beta=v1',\n            });\n        });\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport StripeV3PaymentStrategy from './stripev3-payment-strategy';\nimport StripeV3ScriptLoader from './stripev3-script-loader';\n\nconst createStripeV3PaymentStrategy: PaymentStrategyFactory<any> = (paymentIntegrationService) => {\n    return new StripeV3PaymentStrategy(\n        paymentIntegrationService,\n        new StripeV3ScriptLoader(getScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createStripeV3PaymentStrategy, [{ gateway: 'stripev3' }]);\n","import { PaymentMethod } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\n/**\n * Initialization options.\n */\nexport interface StripeConfigurationOptions {\n    /**\n     * For usage with [Connect](https://stripe.com/docs/connect) only.\n     * Specifying a connected account ID (e.g., acct_24BFMpJ1svR5A89k) allows you to perform actions on behalf of that account.\n     */\n    stripeAccount?: string;\n\n    /**\n     * Override your account's [API version](https://stripe.com/docs/api/versioning)\n     */\n    apiVersion?: string;\n\n    /**\n     * A locale used to globally configure localization in Stripe. Setting the locale here will localize error strings for all Stripe.js methods. It will also configure the locale for Elements and Checkout. Default is auto (Stripe detects the locale of the browser).\n     * Note that Checkout supports a slightly different set of locales than Stripe.js.\n     */\n    locale?: string;\n\n    betas?: string[];\n}\n\nexport interface StripeAdditionalActionData {\n    redirect_url?: string;\n    intent?: string;\n}\n\nexport interface StripeAdditionalAction {\n    type: string;\n    data: StripeAdditionalActionData;\n}\n\n/**\n * The PaymentIntent object.\n */\nexport interface PaymentIntent {\n    /**\n     * Unique identifier for the object.\n     */\n    id: string;\n\n    /**\n     * The client secret of the PaymentIntent. Used for client-side retrieval using a publishable key.\n     */\n    client_secret?: string;\n\n    /**\n     * Status of this PaymentIntent. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).\n     */\n    status: 'succeeded' | string;\n\n    /**\n     * The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.\n     */\n    last_payment_error: LastPaymentError | null;\n\n    payment_method_options?: StripePIPaymentMethodOptions;\n}\n\nexport interface StripePIPaymentMethodSavingOptions {\n    setup_future_usage?: StripeInstrumentSetupFutureUsage;\n    verification_method?: string;\n}\n\nexport interface StripePIPaymentMethodOptions {\n    card?: StripePIPaymentMethodSavingOptions;\n    us_bank_account?: StripePIPaymentMethodSavingOptions;\n}\n\n/**\n * The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.\n */\nexport interface LastPaymentError {\n    /**\n     * A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.\n     */\n    message?: string;\n}\n\n/**\n * This object is used to pass custom fonts when creating an [Elements](https://stripe.com/docs/js/elements_object/create) object.\n */\nexport interface CssFontSource {\n    /**\n     * A relative or absolute URL pointing to a CSS file with [@font-face](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face) definitions, for example:\n     * `https://fonts.googleapis.com/css?family=Open+Sans`\n     * Note that if you are using a [content security policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) (CSP),\n     * [additional directives](https://stripe.com/docs/security#content-security-policy) may be necessary.\n     */\n    cssSrc: string;\n}\n\n/**\n * This object is used to pass custom fonts when creating an [Elements](https://stripe.com/docs/js/elements_object/create) object.\n */\nexport interface CustomFontSource {\n    /**\n     * The name to give the font.\n     */\n    family: string;\n\n    /**\n     * A valid [src](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src) value pointing to your\n     * custom font file. This is usually (though not always) a link to a file with a .woff , .otf, or .svg suffix.\n     */\n    src: string;\n\n    /**\n     * A valid [font-display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display) value.\n     */\n    display?: string;\n\n    /**\n     * One of normal, italic, oblique. Defaults to normal.\n     */\n    style?: string;\n\n    /**\n     * A valid [unicode-range](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range) value.\n     */\n    unicodeRange?: string;\n\n    /**\n     * A valid [font-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight). Note that this is a string, not a number.\n     */\n    weight?: string;\n}\n\nexport type StripeCustomFont = CssFontSource | CustomFontSource;\n\nexport interface StripeError {\n    /**\n     * type of error. When the error type is card_error or validation_error, you can display the error message in error.message directly to your user.\n     */\n    type: string;\n    /**\n     * A human-readable message providing more details about the error. For card errors, these messages can be shown to your users.\n     */\n    message?: string;\n\n    /**\n     * The PaymentIntent object.\n     */\n    payment_intent: PaymentIntent;\n}\n\nexport interface StripeElement {\n    /**\n     * The `element.mount` method attaches your element to the DOM.\n     */\n    mount(domElement: string | HTMLElement): void;\n\n    /**\n     * Removes the element from the DOM and destroys it.\n     * A destroyed element can not be re-activated or re-mounted to the DOM.\n     */\n    destroy(): void;\n\n    /**\n     * Unmounts the element from the DOM.\n     * Call `element.mount` to re-attach it to the DOM.\n     */\n    unmount(): void;\n\n    /**\n     * The change event is triggered when the Element's value changes. The event payload always contains certain keys,\n     * in addition to some Element-specific keys.\n     * https://stripe.com/docs/js/element/events/on_change?type=paymentElement\n     */\n    on(event: StripeElementEvent, handler: (event: StripeEventType) => void): void;\n\n    /**\n     * Updates the options the Payment Element was initialized with. Updates are merged into the existing configuration.\n     * https://docs.stripe.com/js/elements_object/update_payment_element\n     */\n    update(options?: StripeElementsCreateOptions): void;\n\n    /**\n     * This method collapses the Payment Element into a row of payment method tabs.\n     * https://docs.stripe.com/js/elements_object/collapse_payment_element\n     */\n    collapse(): void;\n}\n\nexport interface StripeEvent {\n    complete: boolean;\n    elementType: string;\n    empty: boolean;\n}\n\nexport interface StripeCustomerEvent extends StripeEvent {\n    collapsed?: boolean;\n    authenticated: boolean;\n    value: {\n        email: string;\n    };\n}\n\nexport interface StripeShippingEvent extends StripeEvent {\n    mode?: string;\n    isNewAddress?: boolean;\n    phoneFieldRequired: boolean;\n    value: {\n        address: Address;\n        name?: string;\n        firstName?: string;\n        lastName?: string;\n        phone?: string;\n    };\n    fields?: {\n        phone: string;\n    };\n    display?: {\n        name: string;\n    };\n}\n\nexport interface StripePaymentEvent extends StripeEvent {\n    value: {\n        type: StripePaymentMethodType;\n    };\n    collapsed?: boolean;\n}\n\nexport interface Address {\n    city: string;\n    country: string;\n    line1: string;\n    line2?: string;\n    postal_code: string;\n    state: string;\n}\n\nexport type StripeEventType =\n    | StripeShippingEvent\n    | StripeCustomerEvent\n    | StripePaymentEvent\n    | StripeLinkV2Event;\n\n/**\n * Object definition for part of the data sent to confirm the PaymentIntent.\n * https://stripe.com/docs/api/payment_intents/confirm#confirm_payment_intent-shipping\n */\nexport type AddressOptions = Partial<Address>;\n\nexport interface StripeAddressValues {\n    name?: string;\n    address?: AddressOptions & { country: string };\n}\n\n/**\n * Object definition for part of the data sent to confirm the PaymentIntent.\n * https://stripe.com/docs/js/elements_object/create_payment_element\n */\nexport interface AddressProperties {\n    city?: AutoOrNever;\n    country?: AutoOrNever;\n    state?: AutoOrNever;\n    postalCode?: AutoOrNever;\n    line1?: AutoOrNever;\n    line2?: AutoOrNever;\n}\n\n/**\n * Object definition for part of the data sent to confirm the PaymentIntent.\n */\nexport interface BillingDetailsOptions {\n    name?: string;\n    email?: string;\n    address?: AddressOptions;\n    phone?: string;\n}\n\n/**\n * Object definition for part of the data sent to confirm the PaymentIntent.\n */\nexport interface BillingDetailsProperties {\n    name?: AutoOrNever;\n    email?: AutoOrNever;\n    address?: AutoOrNever | AddressProperties;\n    phone?: AutoOrNever;\n}\n\n/**\n * Object definition for part of the data sent to confirm the PaymentIntent.\n */\nexport interface PaymentMethodDataOptions {\n    billing_details: BillingDetailsOptions;\n    allow_redisplay?: 'always' | 'limited' | 'unspecified';\n}\n\n/**\n * Parameters that will be passed on to the Stripe API to confirm the PaymentIntent.\n */\nexport interface StripeConfirmParams {\n    /*\n     * If you are [handling next actions yourself](https://stripe.com/docs/payments/payment-intents/verifying-status#next-actions), pass in a return_url. If the subsequent action\n     * is redirect_to_url, this URL will be used on the return path for the redirect.\n     *\n     * @recommended\n     */\n    return_url?: string;\n    payment_method_data?: PaymentMethodDataOptions;\n}\n\n/**\n * Data to be sent with a `stripe.confirmPayment` request.\n * Refer to the [Payment Intents API](https://stripe.com/docs/js/payment_intents/confirm_payment) for a full list of parameters.\n */\nexport interface StripeConfirmPaymentData {\n    /**\n     * The Elements instance that was used to create the Payment Element.\n     */\n    elements: StripeElements;\n\n    /**\n     * Parameters that will be passed on to the Stripe API to confirm the PaymentIntent.\n     */\n    confirmParams?: StripeConfirmParams;\n\n    /**\n     * By default, confirmPayment will always redirect to your return_url after a successful confirmation.\n     * If you set redirect: \"if_required\", then confirmPayment will only redirect if your user chooses a redirect-based payment method.\n     */\n    redirect?: StripeStringConstants.ALWAYS | StripeStringConstants.IF_REQUIRED;\n\n    clientSecret?: string;\n}\n\nexport interface StripeCheckoutSessionConfirmPaymentData {\n    redirect?: StripeStringConstants.ALWAYS | StripeStringConstants.IF_REQUIRED;\n    returnUrl?: string;\n}\n\nexport interface FieldsOptions {\n    billingDetails?: AutoOrNever | BillingDetailsProperties;\n    phone?: string;\n}\n\nexport interface WalletOptions {\n    applePay?: AutoOrNever;\n    googlePay?: AutoOrNever;\n    link?: AutoOrNever;\n}\n\nexport interface TermOptions {\n    card?: AutoOrNever;\n}\n\nexport interface StripeLayoutOptions {\n    type?: 'accordion' | 'tabs';\n    linkInAccordion?: boolean;\n    defaultCollapsed?: boolean;\n    radios?: boolean;\n    spacedAccordionItems?: boolean;\n    visibleAccordionItemsCount?: number;\n}\n\n/**\n * All available options are here https://stripe.com/docs/js/elements_object/create_payment_element\n */\nexport interface StripeElementsCreateOptions {\n    mode?: string;\n    fields?: FieldsOptions;\n    wallets?: WalletOptions;\n    allowedCountries?: string[];\n    defaultValues?: ShippingDefaultValues | CustomerDefaultValues | PaymentDefaultValues;\n    validation?: validationElement;\n    display?: { name: StripeDisplayName };\n    terms?: TermOptions;\n    layout?: StripeLayoutOptions;\n    paymentMethodOrder?: string[];\n    //  Link v2 options\n    lineItems?: LineItem[];\n    allowedShippingCountries?: string[];\n    shippingAddressRequired?: boolean;\n    shippingRates?: StripeLinkV2ShippingRate[];\n    billingAddressRequired?: boolean;\n    emailRequired?: boolean;\n    phoneNumberRequired?: boolean;\n    paymentMethods?: {\n        link: StripeStringConstants.AUTO;\n        applePay: StripeStringConstants.NEVER;\n        googlePay: StripeStringConstants.NEVER;\n        amazonPay: StripeStringConstants.NEVER;\n        paypal: StripeStringConstants.NEVER;\n        klarna: StripeStringConstants.NEVER;\n    };\n    buttonHeight?: number;\n    savePaymentMethod?: StripeSavePaymentMethod;\n}\n\ninterface validationElement {\n    phone?: validationRequiredElement;\n}\n\ninterface validationRequiredElement {\n    required?: string;\n}\n\ninterface PaymentDefaultValues {\n    savePaymentMethod?: boolean;\n    billingDetails?: BillingDetailsOptions;\n}\n\ninterface ShippingDefaultValues {\n    name?: string;\n    firstName?: string;\n    lastName?: string;\n    phone: string;\n    address: Address;\n}\n\n/*\nDecide which mode you are going to use the Address Element\nShipping: is used with the Payment Element and Link Authentication Element, it will automatically pass shipping\ninformation when confirming Payment Intent or Setup Intent.\nBilling: is used with the Payment Element, it will automatically pass the billing information when confirming\nPayment Intent or Setup Intent.\n */\nexport enum StripeFormMode {\n    SHIPPING = 'shipping',\n    BILLING = 'billing',\n}\n\nexport enum StripeDisplayName {\n    SPLIT = 'split',\n    FULL = 'full',\n    ORGANIZATION = 'organization',\n}\n\ninterface CustomerDefaultValues {\n    mode: StripeFormMode;\n    email: string;\n    allowedCountries?: string[];\n    display?: {\n        name: StripeDisplayName;\n    };\n}\n\nexport interface StripeElements {\n    /**\n     * Creates an Elements instance, which manages a group of elements.\n     * https://stripe.com/docs/js/elements_object/create\n     */\n    create(elementType: StripeElementType, options?: StripeElementsCreateOptions): StripeElement;\n\n    /**\n     * Looks up a previously created element.\n     * https://stripe.com/docs/js/elements_object/get_payment_element or\n     * https://stripe.com/docs/js/elements_object/get_link_authentication_element\n     */\n    getElement(elementType: StripeElementType): StripeElement | null;\n\n    /**\n     * Updates options on an existing instance of Elements.\n     * https://stripe.com/docs/js/elements_object/update\n     */\n    update(options?: StripeUpdateElementsOptions): StripeElement;\n\n    /**\n     * Fetches updates from the associated PaymentIntent or SetupIntent on an existing instance of Elements,\n     * and reflects these updates in the Payment Element.\n     * https://stripe.com/docs/js/elements_object/fetch_updates\n     */\n    fetchUpdates(): Promise<void>;\n}\n\nexport enum StripeCheckoutSessionStatusType {\n    Open = 'open',\n    Expired = 'expired',\n    Complete = 'complete',\n}\n\nexport enum StripeCheckoutSessionPaymentStatus {\n    Paid = 'paid',\n    UnPaid = 'unpaid',\n    NoPaymentRequired = 'no_payment_required',\n}\n\nexport interface StripeCheckoutSessionStatus {\n    type: StripeCheckoutSessionStatusType;\n    paymentStatus: StripeCheckoutSessionPaymentStatus;\n}\n\nexport interface StripeCheckoutSession {\n    id: string;\n    billingAddress: StripeAddressValues;\n    businessName: string;\n    canConfirm: boolean;\n    currency: string;\n    email: string;\n    phoneNumber: string;\n    shipping: unknown;\n    shippingAddress: StripeAddressValues;\n    shippingOptions: unknown;\n    status: StripeCheckoutSessionStatus;\n    tax: unknown;\n    taxAmounts: unknown;\n    total: unknown;\n}\n\nexport interface StripeCheckoutInstance {\n    loadActions(): Promise<StripeLoadActionsResult>;\n    createPaymentElement(options?: StripeElementsCreateOptions): StripeElement;\n    getPaymentElement(): StripeElement | null;\n}\n\nexport enum StripeLoadActionsResultType {\n    SUCCESS = 'success',\n    ERROR = 'error',\n}\n\nexport interface StripeLoadActionsResult {\n    type: StripeLoadActionsResultType;\n    error?: { message: string };\n    actions?: StripeCheckoutSessionActions;\n}\n\nexport interface StripeCheckoutSessionConfirmationResult {\n    type: StripeLoadActionsResultType;\n    error?: StripeError;\n    session?: StripeCheckoutSession;\n}\n\nexport interface StripeCheckoutSessionActions {\n    updateEmail(email: string): Promise<void>;\n    confirm(\n        options: StripeCheckoutSessionConfirmPaymentData,\n    ): Promise<StripeCheckoutSessionConfirmationResult>;\n}\n\n/**\n * All available options are here https://stripe.com/docs/stripe-js/appearance-api#supported-css-properties\n */\nexport interface StripeAppearanceOptions {\n    variables?: Record<string, StripeAppearanceValues>;\n\n    rules?: Record<string, Record<string, StripeAppearanceValues>>;\n}\n\nexport type StripeAppearanceValues = string | string[] | number | undefined;\n\nexport interface StripeElementsOptions {\n    /**\n     * An array of custom fonts, which elements created from the Elements object can use.\n     * Fonts can be specified as [CssFontSource](https://stripe.com/docs/js/appendix/css_font_source_object)\n     * or [CustomFontSource](https://stripe.com/docs/js/appendix/custom_font_source_object) objects.\n     */\n    fonts?: StripeCustomFont[];\n\n    /**\n     * A [locale](https://stripe.com/docs/js/appendix/supported_locales) to display placeholders and\n     * error strings in. Default is auto (Stripe detects the locale of the browser).\n     * Setting the locale does not affect the behavior of postal code validationa valid postal code\n     * for the billing country of the card is still required.\n     */\n    locale?: string;\n\n    /**\n     * The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.\n     * The client secret can be used to complete a payment from your frontend.\n     * It should not be stored, logged, embedded in URLs, or exposed to anyone other than the customer.\n     * Make sure that you have TLS enabled on any page that includes the client secret.\n     * Refer to our docs to accept a payment and learn about how client_secret should be handled.\n     */\n    clientSecret?: string;\n\n    /**\n     * A token that represents the Stripe customer session.\n     * Stripe documentation: https://docs.stripe.com/api/checkout/sessions\n     */\n    customerSessionClientSecret?: string;\n\n    /**\n     * Match the design of your site with the appearance option.\n     * The layout of each Element stays consistent, but you can modify colors, fonts, borders, padding, and more.\n     */\n    appearance?: StripeAppearanceOptions;\n\n    mode?: string;\n    amount?: number;\n    currency?: string;\n    paymentMethodTypes?: string[];\n}\n\nexport interface StripeInitCheckoutOptions {\n    clientSecret: string;\n    elementsOptions?: StripeCheckoutSessionElementOptions;\n    adaptivePricing?: {\n        allowed: boolean;\n    };\n    defaultValues?: StripeCheckoutSessionDefaultValues;\n    wallets?: any;\n}\n\nexport interface StripeCheckoutSessionElementOptions {\n    appearance?: StripeAppearanceOptions;\n    loader?: StripeStringConstants;\n    fonts?: StripeCustomFont[];\n    savedPaymentMethod?: {\n        enableRedisplay?: StripeStringConstants;\n        enableSave?: StripeStringConstants;\n    };\n}\n\nexport interface StripeCheckoutSessionDefaultValues {\n    billingAddress?: StripeAddressValues;\n    shippingAddress?: StripeAddressValues;\n    email?: string;\n    phoneNumber?: string;\n}\n\nexport interface StripeUpdateElementsOptions {\n    /**\n     * A [locale](https://stripe.com/docs/js/appendix/supported_locales) to display placeholders and\n     * error strings in. Default is auto (Stripe detects the locale of the browser).\n     * Setting the locale does not affect the behavior of postal code validationa valid postal code\n     * for the billing country of the card is still required.\n     */\n    locale?: string;\n\n    /**\n     * Match the design of your site with the appearance option.\n     * The layout of each Element stays consistent, but you can modify colors, fonts, borders, padding, and more.\n     */\n    appearance?: StripeAppearanceOptions;\n    mode?: string;\n    amount?: number;\n    currency?: string;\n}\n\nexport interface StripeClient {\n    /**\n     * Use confirmPayment to confirm a PaymentIntent using data collected by the Payment Element.\n     * When called, confirmPayment will attempt to complete any required actions,\n     * such as authenticating your user by displaying a 3DS dialog or redirecting them to a bank authorization page.\n     */\n    confirmPayment(options: StripeConfirmPaymentData): Promise<StripeResult>;\n\n    /**\n     * When called, it will confirm the PaymentIntent with data you provide and carry out 3DS or other next actions if they are required.\n     */\n    confirmCardPayment(clientSecret: string): Promise<StripeResult>;\n\n    /**\n     * Retrieve a PaymentIntent using its client secret.\n     */\n    retrievePaymentIntent(clientSecret: string): Promise<StripeResult>;\n\n    /**\n     * Create an `Elements` instance, which manages a group of elements.\n     */\n    elements(options: StripeElementsOptions): StripeElements;\n\n    initCheckout(options: StripeInitCheckoutOptions): Promise<StripeCheckoutInstance>;\n}\n\nexport interface StripeResult {\n    paymentIntent?: PaymentIntent;\n    error?: StripeError;\n}\n\nexport interface StripeHostWindow extends Window {\n    bcStripeClient?: StripeClient;\n    bcStripeElements?: StripeElements;\n    bcStripeCheckout?: StripeCheckoutInstance;\n    Stripe?<T = StripeClient>(\n        stripePublishableKey: string,\n        options?: StripeConfigurationOptions,\n    ): T;\n}\n\nexport enum StripePaymentMethodType {\n    CreditCard = 'card',\n    Link = 'link',\n    EPS = 'eps',\n    GRABPAY = 'grabpay',\n    BANCONTACT = 'bancontact',\n    IDEAL = 'ideal',\n    ALIPAY = 'alipay',\n    KLARNA = 'klarna',\n    OCS = 'optimized_checkout',\n}\n\ntype AutoOrNever = StripeStringConstants.AUTO | StripeStringConstants.NEVER;\n\nexport enum StripeStringConstants {\n    NEVER = 'never',\n    AUTO = 'auto',\n    ALWAYS = 'always',\n    PAYMENT = 'payment',\n    IF_REQUIRED = 'if_required',\n}\n\nexport enum StripeJsVersion {\n    V3 = 'v3',\n    ACACIA = 'acacia',\n    BASIL = 'basil',\n    CLOVER = 'clover',\n}\n\nexport enum StripeElementType {\n    PAYMENT = 'payment',\n    AUTHENTICATION = 'linkAuthentication',\n    SHIPPING = 'address',\n    EXPRESS_CHECKOUT = 'expressCheckout',\n}\n\nexport enum StripePaymentIntentStatus {\n    REQUIRES_PAYMENT_METHOD = 'requires_payment_method',\n    REQUIRES_CONFIRMATION = 'requires_confirmation',\n    REQUIRES_ACTION = 'requires_action',\n    PROCESSING = 'processing',\n    SUCCEEDED = 'succeeded',\n    CANCELED = 'canceled',\n}\n\nexport interface StripePaymentMethod extends PaymentMethod {\n    initializationData: StripeInitializationData;\n}\n\nexport interface StripeInitializationData {\n    stripePublishableKey: string;\n    stripeConnectedAccount: string;\n    shopperLanguage: string;\n    customerSessionToken?: string;\n    enableLink?: boolean;\n    allowRedisplayForStoredInstruments?: boolean;\n    captureMethod?: 'automatic' | 'manual';\n    useNewStripeJsVersion?: boolean;\n}\n\nexport interface StripeElementUpdateOptions {\n    shouldShowTerms?: boolean;\n}\n\nexport interface StripeAdditionalActionRequired {\n    type: string;\n    data: {\n        token?: string;\n        redirect_url?: string;\n    };\n}\n\nexport interface StripeAdditionalActionResponseBody {\n    additional_action_required: StripeAdditionalActionRequired;\n    three_ds_result: {\n        token?: string;\n    };\n}\n\nexport enum StripeElementEvent {\n    CLICK = 'click',\n    CHANGE = 'change',\n    READY = 'ready',\n    SHIPPING_ADDRESS_CHANGE = 'shippingaddresschange',\n    SHIPPING_RATE_CHANGE = 'shippingratechange',\n    CONFIRM = 'confirm',\n    CANCEL = 'cancel',\n    LOADER_START = 'loaderstart',\n}\n\nexport interface LineItem {\n    name: string;\n    amount: number;\n}\n\nexport interface StripeSavePaymentMethod {\n    maxVisiblePaymentMethods?: number;\n}\n\nexport enum StripeInstrumentSetupFutureUsage {\n    ON_SESSION = 'on_session',\n    OFF_SESSION = 'off_session',\n}\n\nexport interface StripeLinkV2Event {\n    value?: null;\n    billingDetails?: {\n        name?: string;\n        email?: string;\n        phone?: string;\n        address?: {\n            line1?: string;\n            city?: string;\n            country?: string;\n            postal_code?: string;\n            state?: string;\n        };\n    };\n    shippingAddress?: {\n        name?: string;\n        address?: {\n            line1?: string;\n            line2?: string;\n            city?: string;\n            country?: string;\n            postal_code?: string;\n            state?: string;\n        };\n    };\n    address?: {\n        line1?: string;\n        city?: string;\n        country?: string;\n        postal_code?: string;\n        state?: string;\n    };\n    shippingRate?: StripeLinkV2ShippingRate;\n    elementType: string;\n    expressPaymentType: string;\n    resolve(data: StripeLinkV2EventResolveData): void;\n    reject(): void;\n}\n\nexport interface StripeLinkV2EventResolveData {\n    lineItems?: LineItem[];\n    allowedShippingCountries?: string[];\n    shippingAddressRequired?: boolean;\n    shippingRates?: StripeLinkV2ShippingRate[];\n    billingAddressRequired?: boolean;\n    emailRequired?: boolean;\n    phoneNumberRequired?: boolean;\n}\n\nexport interface StripeLinkV2ShippingRate {\n    id: string;\n    amount: number;\n    displayName: string;\n}\n\nexport interface StripeLinkV2Options {\n    clientSecret?: string;\n    mode?: string;\n    currency?: string;\n    captureMethod?: 'automatic' | 'manual';\n    amount?: number;\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport { PaymentMethodClientUnavailableError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport {\n    StripeCheckoutInstance,\n    StripeClient,\n    StripeElements,\n    StripeElementsOptions,\n    StripeHostWindow,\n    StripeInitCheckoutOptions,\n    StripeInitializationData,\n    StripeJsVersion,\n} from './stripe';\n\nexport default class StripeScriptLoader {\n    constructor(\n        private scriptLoader: ScriptLoader,\n        private stripeWindow: StripeHostWindow = window,\n    ) {}\n\n    async getStripeClient(\n        initializationData: StripeInitializationData,\n        locale?: string,\n        stripeJsVersion?: string,\n        betas?: string[],\n        apiVersion?: string,\n    ): Promise<StripeClient> {\n        if (this.stripeWindow.bcStripeClient) {\n            return this.stripeWindow.bcStripeClient;\n        }\n\n        const stripe = await this.load(stripeJsVersion);\n        const { stripePublishableKey, stripeConnectedAccount } = initializationData;\n        const options = {\n            ...(stripeConnectedAccount ? { stripeAccount: stripeConnectedAccount } : {}),\n            ...(locale ? { locale } : {}),\n            ...(betas ? { betas } : {}),\n            ...(apiVersion ? { apiVersion } : {}),\n        };\n\n        const stripeClient = stripe<StripeClient>(stripePublishableKey, options);\n\n        Object.assign(this.stripeWindow, { bcStripeClient: stripeClient });\n\n        return stripeClient;\n    }\n\n    async getElements(\n        stripeClient: StripeClient,\n        options: StripeElementsOptions,\n    ): Promise<StripeElements> {\n        let stripeElements = this.stripeWindow.bcStripeElements;\n\n        if (!stripeElements) {\n            stripeElements = stripeClient.elements(options);\n\n            Object.assign(this.stripeWindow, { bcStripeElements: stripeElements });\n        } else {\n            await this.updateStripeElements(options);\n        }\n\n        return stripeElements;\n    }\n\n    async updateStripeElements(options: StripeElementsOptions) {\n        const stripeElements = this.stripeWindow.bcStripeElements;\n\n        if (!stripeElements) {\n            return;\n        }\n\n        stripeElements.update(options);\n        await stripeElements.fetchUpdates();\n    }\n\n    async getStripeCheckout(\n        stripeClient: StripeClient,\n        options: StripeInitCheckoutOptions,\n    ): Promise<StripeCheckoutInstance> {\n        let stripeCheckout = this.stripeWindow.bcStripeCheckout;\n\n        if (!stripeCheckout) {\n            stripeCheckout = await stripeClient.initCheckout(options);\n\n            Object.assign(this.stripeWindow, { bcStripeCheckout: stripeCheckout });\n        }\n\n        return stripeCheckout;\n    }\n\n    private async load(stripeJsVersion?: string) {\n        if (!this.stripeWindow.Stripe) {\n            await this.scriptLoader.loadScript(this.getScriptUrl(stripeJsVersion));\n\n            if (!this.stripeWindow.Stripe) {\n                throw new PaymentMethodClientUnavailableError();\n            }\n        }\n\n        return this.stripeWindow.Stripe;\n    }\n\n    private getScriptUrl(stripeJsVersion?: string) {\n        if (!stripeJsVersion || stripeJsVersion === StripeJsVersion.V3) {\n            return 'https://js.stripe.com/v3/';\n        }\n\n        return `https://js.stripe.com/${stripeJsVersion}/stripe.js`;\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a payment method experiences some kind of\n * failure (i.e.: its client library returns a rejected promise). And there is\n * no other error type that is more specific than this one.\n */\nexport default class PaymentMethodFailedError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method has thrown an unexpected error.',\n        );\n\n        this.name = 'PaymentMethodFailedError';\n        this.type = 'payment_method_client_invalid';\n    }\n}\n","import { includes, some } from 'lodash';\n\nimport {\n    Address,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodFailedError,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { isStripeError } from './is-stripe-error';\nimport {\n    AddressOptions,\n    StripeAdditionalActionRequired,\n    StripeClient,\n    StripeConfirmPaymentData,\n    StripeElement,\n    StripeElements,\n    StripeElementType,\n    StripeError,\n    StripeInitializationData,\n    StripeJsVersion,\n    StripePaymentIntentStatus,\n    StripeStringConstants,\n} from './stripe';\nimport StripePaymentInitializeOptions from './stripe-initialize-options';\nimport StripeScriptLoader from './stripe-script-loader';\n\nexport default class StripeIntegrationService {\n    private isMounted = false;\n    private checkoutEventsUnsubscribe?: () => void;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n    ) {}\n\n    deinitialize(): void {\n        this.checkoutEventsUnsubscribe?.();\n        this.isMounted = false;\n    }\n\n    initCheckoutEventsSubscription(\n        gatewayId: string,\n        methodId: string,\n        stripeInitializationOptions: StripePaymentInitializeOptions,\n        stripeElements?: StripeElements,\n    ): void {\n        this.checkoutEventsUnsubscribe = this.paymentIntegrationService.subscribe(\n            async () => {\n                const paymentElement = stripeElements?.getElement(StripeElementType.PAYMENT);\n\n                if (!paymentElement) {\n                    return;\n                }\n\n                try {\n                    await this.updateStripePaymentIntent(gatewayId, methodId);\n                } catch (error) {\n                    if (this.isMounted) {\n                        paymentElement.unmount();\n                        this.isMounted = false;\n                    }\n\n                    if (error instanceof Error) {\n                        stripeInitializationOptions.onError?.(error);\n                    }\n\n                    return;\n                }\n\n                if (!this.isMounted) {\n                    await stripeElements?.fetchUpdates();\n                    this.mountElement(paymentElement, stripeInitializationOptions.containerId);\n                }\n            },\n            (state) => state.getCheckout()?.outstandingBalance,\n            (state) => state.getCheckout()?.coupons,\n        );\n    }\n\n    mountElement(stripeElement: StripeElement, containerId: string): void {\n        if (!document.getElementById(containerId)) {\n            return;\n        }\n\n        stripeElement.mount(`#${containerId}`);\n        this.isMounted = true;\n    }\n\n    mapAppearanceVariables(styles: NonNullable<StripePaymentInitializeOptions['style']>) {\n        return {\n            colorPrimary: styles.fieldInnerShadow,\n            colorBackground: styles.fieldBackground,\n            colorText: styles.labelText,\n            colorDanger: styles.fieldErrorText,\n            colorTextSecondary: styles.labelText,\n            colorTextPlaceholder: styles.fieldPlaceholderText,\n            colorIcon: styles.fieldPlaceholderText,\n        };\n    }\n\n    mapInputAppearanceRules(styles: NonNullable<StripePaymentInitializeOptions['style']>) {\n        return {\n            borderColor: styles.fieldBorder,\n            color: styles.fieldText,\n            boxShadow: styles.fieldInnerShadow,\n        };\n    }\n\n    throwStripeError(stripeError?: unknown): never {\n        if (isStripeError(stripeError)) {\n            this.throwDisplayableStripeError(stripeError);\n\n            if (this.isCancellationError(stripeError)) {\n                throw new PaymentMethodCancelledError();\n            }\n        }\n\n        throw new PaymentMethodFailedError();\n    }\n\n    throwDisplayableStripeError(stripeError: StripeError) {\n        if (\n            includes(['card_error', 'invalid_request_error', 'validation_error'], stripeError.type)\n        ) {\n            throw new Error(stripeError.message);\n        }\n    }\n\n    isCancellationError(stripeError?: StripeError): boolean {\n        const errorMessage = stripeError?.payment_intent.last_payment_error?.message;\n\n        return !!errorMessage && errorMessage.indexOf('canceled') !== -1;\n    }\n\n    throwPaymentConfirmationProceedMessage() {\n        // INFO: for case if payment was successfully confirmed on Stripe side but on BC side something go wrong, request failed and order status hasn't changed yet\n        // For shopper we need to show additional message that BC is waiting for stripe confirmation, to prevent additional payment creation\n        throw new PaymentMethodFailedError(\n            \"We've received your order and are processing your payment. Once the payment is verified, your order will be completed. We will send you an email when it's completed. Please note, this process may take a few minutes depending on the processing times of your chosen method.\",\n        );\n    }\n\n    async isPaymentCompleted(methodId: string, stripeUPEClient?: StripeClient): Promise<boolean> {\n        const state = this.paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId);\n        const { features } = state.getStoreConfigOrThrow().checkoutSettings;\n\n        if (\n            !paymentMethod.clientToken ||\n            !stripeUPEClient ||\n            !features['PI-626.Block_unnecessary_payment_confirmation_for_StripeUPE']\n        ) {\n            return false;\n        }\n\n        const { paymentIntent } = await stripeUPEClient.retrievePaymentIntent(\n            paymentMethod.clientToken,\n        );\n\n        return paymentIntent?.status === StripePaymentIntentStatus.SUCCEEDED;\n    }\n\n    mapStripePaymentData(\n        stripeElements?: StripeElements,\n        returnUrl?: string,\n        shouldAllowRedisplay = false,\n    ): StripeConfirmPaymentData {\n        const billingAddress = this.paymentIntegrationService.getState().getBillingAddress();\n        const { firstName = '', lastName = '', email = '' } = billingAddress || {};\n        const address = this._mapStripeAddress(billingAddress);\n\n        if (!stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!email || !address || !address.city || !address.country || !firstName || !lastName) {\n            throw new MissingDataError(MissingDataErrorType.MissingBillingAddress);\n        }\n\n        return {\n            elements: stripeElements,\n            redirect: StripeStringConstants.IF_REQUIRED,\n            confirmParams: {\n                payment_method_data: {\n                    ...(shouldAllowRedisplay ? { allow_redisplay: 'always' } : {}),\n                    billing_details: {\n                        email,\n                        address,\n                        name: `${firstName} ${lastName}`,\n                    },\n                },\n                ...(returnUrl && { return_url: returnUrl }),\n            },\n        };\n    }\n\n    isAdditionalActionError(errors: Array<{ code: string }>): boolean {\n        return some(errors, { code: 'additional_action_required' });\n    }\n\n    isRedirectAction(additionalAction: StripeAdditionalActionRequired): boolean {\n        const {\n            type,\n            data: { redirect_url },\n        } = additionalAction;\n\n        return type === 'redirect_to_url' && !!redirect_url;\n    }\n\n    isOnPageAdditionalAction(additionalAction: StripeAdditionalActionRequired): boolean {\n        const {\n            type,\n            data: { token },\n        } = additionalAction;\n\n        return type === 'additional_action_requires_payment_method' && !!token;\n    }\n\n    async updateStripePaymentIntent(gatewayId: string, methodId: string): Promise<void> {\n        // INFO: to trigger payment intent update on the BE side we need to make stripe config request\n        const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n        const { clientToken } = state.getPaymentMethodOrThrow(methodId);\n\n        if (!clientToken) {\n            // INFO: no need to update Stripe Element if client token is not present\n            return;\n        }\n\n        this.scriptLoader.updateStripeElements({ clientSecret: clientToken });\n    }\n\n    getStripeJsVersion(initializationData: StripeInitializationData): StripeJsVersion {\n        return initializationData.useNewStripeJsVersion\n            ? StripeJsVersion.CLOVER\n            : StripeJsVersion.V3;\n    }\n\n    private _mapStripeAddress(address?: Address): AddressOptions {\n        if (address) {\n            const {\n                city,\n                address1,\n                address2,\n                countryCode: country,\n                postalCode,\n                stateOrProvinceCode,\n            } = address;\n\n            return {\n                city,\n                country,\n                postal_code: postalCode,\n                line1: address1,\n                line2: address2,\n                ...(stateOrProvinceCode ? { state: stateOrProvinceCode } : {}),\n            };\n        }\n\n        throw new MissingDataError(MissingDataErrorType.MissingBillingAddress);\n    }\n}\n","import { StripeError } from './stripe';\n\nexport function isStripeError(error: unknown): error is StripeError {\n    return typeof error === 'object' && error !== null && 'type' in error;\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport StandardError from './standard-error';\n\nconst DEFAULT_RESPONSE = {\n    body: {},\n    headers: {},\n    status: 0,\n};\n\n/**\n * Throw this error if we are unable to make a request to the server. It wraps\n * any server response into a JS error object.\n */\nexport default class RequestError<TBody = any> extends StandardError {\n    body: TBody | {};\n    headers: { [key: string]: any };\n    errors: Array<{ code: string; message?: string }>;\n    status: number;\n\n    constructor(\n        response?: Response<TBody | {}>,\n        {\n            message,\n            errors,\n        }: {\n            message?: string;\n            errors?: Array<{ code: string; message?: string }>;\n        } = {},\n    ) {\n        const { body, headers, status } = response || DEFAULT_RESPONSE;\n\n        super(message || 'An unexpected error has occurred.');\n\n        this.name = 'RequestError';\n        this.type = 'request';\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.errors = errors || [];\n    }\n}\n","import { PaymentMethod } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { StripePaymentMethod } from './stripe';\n\nexport function isStripePaymentMethodLike(\n    paymentMethod: PaymentMethod,\n): paymentMethod is StripePaymentMethod {\n    return (\n        typeof paymentMethod === 'object' &&\n        paymentMethod !== null &&\n        'initializationData' in paymentMethod &&\n        (paymentMethod as StripePaymentMethod).initializationData !== undefined &&\n        (paymentMethod as StripePaymentMethod).initializationData !== null &&\n        typeof (paymentMethod as StripePaymentMethod).initializationData === 'object' &&\n        'stripePublishableKey' in (paymentMethod as StripePaymentMethod).initializationData &&\n        'stripeConnectedAccount' in (paymentMethod as StripePaymentMethod).initializationData &&\n        'shopperLanguage' in (paymentMethod as StripePaymentMethod).initializationData &&\n        typeof (paymentMethod as StripePaymentMethod).initializationData.stripePublishableKey !==\n            'undefined' &&\n        typeof (paymentMethod as StripePaymentMethod).initializationData.stripeConnectedAccount !==\n            'undefined' &&\n        typeof (paymentMethod as StripePaymentMethod).initializationData.shopperLanguage !==\n            'undefined'\n    );\n}\n","export const supportedLocales: Record<string, string[]> = {\n    ar: ['ar'],\n    bg: ['bg'],\n    cs: ['cs'],\n    da: ['da'],\n    de: ['de'],\n    el: ['el'],\n    en: ['en', 'en-GB'],\n    es: ['es', 'es-419'],\n    et: ['et'],\n    fi: ['fi'],\n    fil: ['fil'],\n    fr: ['fr', 'fr-CA'],\n    he: ['he'],\n    hr: ['hr'],\n    hu: ['hu'],\n    id: ['id'],\n    it: ['it'],\n    ja: ['ja'],\n    ko: ['ko'],\n    lt: ['lt'],\n    lv: ['lv'],\n    ms: ['ms'],\n    mt: ['mt'],\n    nb: ['nb'],\n    nl: ['nl'],\n    pl: ['pl'],\n    pt: ['pt', 'pt-BR'],\n    ro: ['ro'],\n    ru: ['ru'],\n    sk: ['sk'],\n    sl: ['sl'],\n    sv: ['sv'],\n    th: ['th'],\n    tr: ['tr'],\n    vi: ['vi'],\n    zh: ['zh', 'zh-HK', 'zh-TW'],\n};\n","import { supportedLocales } from './stripe-supported-locales';\n\nexport default function formatLocale(localeLanguage: string): string {\n    const [language, country] = localeLanguage.replace(/_/g, '-').toLowerCase().split('-');\n    const countryLocales = supportedLocales[language];\n\n    if (!countryLocales) {\n        return 'auto';\n    }\n\n    const formattedLocale = country ? `${language}-${country.toUpperCase()}` : language;\n\n    return countryLocales.indexOf(formattedLocale) > -1 ? formattedLocale : countryLocales[0];\n}\n","export const STRIPE_UPE_CLIENT_BETAS = [\n    'payment_element_beta_2',\n    'alipay_pm_beta_1',\n    'link_default_integration_beta_1',\n    'shipping_address_element_beta_1',\n    'address_element_beta_1',\n];\n\nexport const STRIPE_UPE_CLIENT_API_VERSION = '2020-03-02;alipay_beta=v1;link_beta=v1';\n","import {\n    PaymentProviderCustomer,\n    StripeAcceleratedCheckoutCustomer,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nexport default function isStripeAcceleratedCheckoutCustomer(\n    customer: PaymentProviderCustomer,\n): customer is StripeAcceleratedCheckoutCustomer {\n    return 'stripeLinkAuthenticationState' in customer;\n}\n","import { some } from 'lodash';\n\nimport {\n    FormattedHostedInstrument,\n    InvalidArgumentError,\n    isHostedInstrumentLike,\n    isRequestError,\n    isVaultedInstrument,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    Payment,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationSelectors,\n    PaymentIntegrationService,\n    PaymentMethodFailedError,\n    PaymentRequestOptions,\n    PaymentStrategy,\n    RequestError,\n    StripeUPEIntent,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    formatStripeLocale,\n    isStripePaymentMethodLike,\n    STRIPE_UPE_CLIENT_API_VERSION,\n    STRIPE_UPE_CLIENT_BETAS,\n    StripeAdditionalActionRequired,\n    StripeAppearanceOptions,\n    StripeClient,\n    StripeElement,\n    StripeElementEvent,\n    StripeElements,\n    StripeElementsCreateOptions,\n    StripeElementType,\n    StripeElementUpdateOptions,\n    StripeError,\n    StripeEventType,\n    StripeInitializationData,\n    StripeIntegrationService,\n    StripeJsVersion,\n    StripePaymentMethodType,\n    StripeResult,\n    StripeScriptLoader,\n    StripeStringConstants,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport isStripeAcceleratedCheckoutCustomer from './is-stripe-accelerated-checkout-customer';\nimport StripeUPEPaymentInitializeOptions, {\n    WithStripeUPEPaymentInitializeOptions,\n} from './stripe-upe-initialize-options';\n\nexport default class StripeUPEPaymentStrategy implements PaymentStrategy {\n    private _stripeUPEClient?: StripeClient;\n    private _stripeElements?: StripeElements;\n    private _isStripeElementUpdateEnabled?: boolean;\n    private _allowRedisplayForStoredInstruments?: boolean;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n        private stripeIntegrationService: StripeIntegrationService,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithStripeUPEPaymentInitializeOptions,\n    ): Promise<void> {\n        const { stripeupe, methodId, gatewayId } = options;\n\n        if (!stripeupe?.containerId) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!gatewayId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"gatewayId\" argument is not provided.',\n            );\n        }\n\n        this._loadStripeElement(stripeupe, gatewayId, methodId).catch((error) =>\n            stripeupe.onError?.(error),\n        );\n\n        this.stripeIntegrationService.initCheckoutEventsSubscription(\n            gatewayId,\n            methodId,\n            stripeupe,\n            this._stripeElements,\n        );\n\n        return Promise.resolve();\n    }\n\n    async execute(orderRequest: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        const { payment, ...order } = orderRequest;\n\n        if (!payment || !payment.paymentData) {\n            throw new PaymentArgumentInvalidError(['payment.paymentData']);\n        }\n\n        if (!this._stripeUPEClient) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { paymentData, methodId, gatewayId } = payment;\n        const { shouldSaveInstrument = false, shouldSetAsDefaultInstrument = false } =\n            isHostedInstrumentLike(paymentData) ? paymentData : {};\n        const state = this.paymentIntegrationService.getState();\n        const { isStoreCreditApplied: useStoreCredit } = state.getCheckoutOrThrow();\n        const paymentProviderCustomer = state.getPaymentProviderCustomerOrThrow();\n        const stripePaymentProviderCustomer = isStripeAcceleratedCheckoutCustomer(\n            paymentProviderCustomer,\n        )\n            ? paymentProviderCustomer\n            : {};\n        const stripeLinkAuthenticationState =\n            stripePaymentProviderCustomer.stripeLinkAuthenticationState;\n\n        if (useStoreCredit) {\n            await this.paymentIntegrationService.applyStoreCredit(useStoreCredit);\n        }\n\n        if (gatewayId) {\n            await this.stripeIntegrationService.updateStripePaymentIntent(gatewayId, methodId);\n\n            const { email } = state.getCustomerOrThrow();\n\n            if (stripeLinkAuthenticationState !== undefined && !email) {\n                const billingAddress = state.getBillingAddressOrThrow();\n\n                await this.paymentIntegrationService.updateBillingAddress(billingAddress);\n            }\n        }\n\n        await this.paymentIntegrationService.submitOrder(order, options);\n\n        if (isVaultedInstrument(paymentData)) {\n            const { instrumentId } = paymentData;\n\n            await this._executeWithVaulted(\n                payment.methodId,\n                instrumentId,\n                shouldSetAsDefaultInstrument,\n            );\n\n            return;\n        }\n\n        await this._executeWithStripeConfirmation(\n            payment.methodId,\n            stripeLinkAuthenticationState ? false : shouldSaveInstrument,\n            shouldSetAsDefaultInstrument,\n        );\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    deinitialize(): Promise<void> {\n        this._stripeElements?.getElement(StripeElementType.PAYMENT)?.unmount();\n        this.stripeIntegrationService.deinitialize();\n        this._stripeElements = undefined;\n        this._stripeUPEClient = undefined;\n\n        return Promise.resolve();\n    }\n\n    private async _executeWithStripeConfirmation(\n        methodId: string,\n        shouldSaveInstrument?: boolean,\n        shouldSetAsDefaultInstrument?: boolean,\n    ): Promise<void> {\n        const state = this.paymentIntegrationService.getState();\n        const { clientToken } = state.getPaymentMethodOrThrow(methodId);\n        const paymentPayload = this._getPaymentPayload(\n            methodId,\n            clientToken || '',\n            shouldSaveInstrument,\n            shouldSetAsDefaultInstrument,\n        );\n\n        try {\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            await this._processAdditionalActionWithStripeConfirmation(\n                error,\n                methodId,\n                shouldSaveInstrument,\n                shouldSetAsDefaultInstrument,\n            );\n        }\n    }\n\n    private async _executeWithVaulted(\n        methodId: string,\n        token: string,\n        shouldSetAsDefaultInstrument: boolean,\n    ): Promise<PaymentIntegrationSelectors | void> {\n        const state = this.paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId);\n        const cartId = state.getCart()?.id;\n\n        try {\n            const paymentPayload = {\n                methodId,\n                paymentData: {\n                    formattedPayload: {\n                        cart_id: cartId,\n                        bigpay_token: { token },\n                        confirm: false,\n                        client_token: paymentMethod.clientToken,\n                        set_as_default_stored_instrument: shouldSetAsDefaultInstrument,\n                    },\n                },\n            };\n\n            return await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            return this._processVaultedAdditionalAction(\n                error,\n                methodId,\n                shouldSetAsDefaultInstrument,\n            );\n        }\n    }\n\n    private async _loadStripeElement(\n        stripeupe: StripeUPEPaymentInitializeOptions,\n        gatewayId: string,\n        methodId: string,\n    ) {\n        const { containerId, style, render, initStripeElementUpdateTrigger } = stripeupe;\n        const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId);\n\n        if (!isStripePaymentMethodLike(paymentMethod)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { clientToken, initializationData } = paymentMethod;\n        const {\n            shopperLanguage,\n            allowRedisplayForStoredInstruments = false,\n            enableLink,\n        } = initializationData;\n\n        this._allowRedisplayForStoredInstruments = allowRedisplayForStoredInstruments;\n\n        if (!clientToken) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        this._stripeUPEClient = await this._loadStripeJs(initializationData);\n        this._isStripeElementUpdateEnabled = typeof initStripeElementUpdateTrigger === 'function';\n\n        let appearance: StripeAppearanceOptions | undefined;\n\n        if (style) {\n            const styles = style;\n\n            appearance = {\n                variables: this.stripeIntegrationService.mapAppearanceVariables(style),\n                rules: {\n                    '.Input': this.stripeIntegrationService.mapInputAppearanceRules(styles),\n                },\n            };\n        }\n\n        this._stripeElements = await this.scriptLoader.getElements(this._stripeUPEClient, {\n            clientSecret: clientToken,\n            locale: formatStripeLocale(shopperLanguage),\n            appearance,\n        });\n\n        const { getBillingAddress, getShippingAddress } = state;\n        const { postalCode } = getShippingAddress() || getBillingAddress() || {};\n\n        const stripeElement: StripeElement =\n            this._stripeElements.getElement(StripeElementType.PAYMENT) ||\n            this._stripeElements.create(StripeElementType.PAYMENT, {\n                fields: {\n                    billingDetails: {\n                        email: StripeStringConstants.NEVER,\n                        address: {\n                            country: StripeStringConstants.NEVER,\n                            city: StripeStringConstants.NEVER,\n                            postalCode: postalCode\n                                ? StripeStringConstants.NEVER\n                                : StripeStringConstants.AUTO,\n                        },\n                    },\n                },\n                wallets: {\n                    applePay: StripeStringConstants.NEVER,\n                    googlePay: StripeStringConstants.NEVER,\n                    link: enableLink ? StripeStringConstants.AUTO : StripeStringConstants.NEVER,\n                },\n                ...this._getStripeElementTerms(),\n            });\n\n        this.stripeIntegrationService.mountElement(stripeElement, containerId);\n\n        stripeElement.on(StripeElementEvent.READY, () => {\n            render();\n        });\n\n        stripeElement.on(StripeElementEvent.CHANGE, (event: StripeEventType) => {\n            if (!event?.value || !('type' in event.value)) {\n                return;\n            }\n\n            this._updateStripeLinkStateByElementType(event.value.type);\n        });\n\n        if (this._isStripeElementUpdateEnabled) {\n            initStripeElementUpdateTrigger?.(this._updateStripeElement.bind(this));\n        }\n    }\n\n    private async _processAdditionalActionWithStripeConfirmation(\n        error: unknown,\n        methodId: string,\n        shouldSaveInstrument = false,\n        shouldSetAsDefaultInstrument = false,\n    ): Promise<void> {\n        if (\n            !isRequestError(error) ||\n            !this.stripeIntegrationService.isAdditionalActionError(error.body.errors)\n        ) {\n            throw error;\n        }\n\n        if (!this._stripeUPEClient || !this._stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { data: additionalActionData } = error.body.additional_action_required;\n        const { token } = additionalActionData;\n\n        const { paymentIntent } = await this._confirmStripePaymentOrThrow(\n            methodId,\n            additionalActionData,\n        );\n\n        const paymentPayload = this._getPaymentPayload(\n            methodId,\n            paymentIntent?.id || token,\n            shouldSaveInstrument,\n            shouldSetAsDefaultInstrument,\n        );\n\n        try {\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            this.stripeIntegrationService.throwPaymentConfirmationProceedMessage();\n        }\n    }\n\n    private async _confirmStripePaymentOrThrow(\n        methodId: string,\n        additionalActionData: StripeAdditionalActionRequired['data'],\n    ): Promise<StripeResult | never> {\n        const { token, redirect_url } = additionalActionData;\n        const stripePaymentData = this.stripeIntegrationService.mapStripePaymentData(\n            this._stripeElements,\n            redirect_url,\n            !!this._allowRedisplayForStoredInstruments,\n        );\n        let stripeError: StripeError | undefined;\n\n        try {\n            const isPaymentCompleted = await this.stripeIntegrationService.isPaymentCompleted(\n                methodId,\n                this._stripeUPEClient,\n            );\n\n            const confirmationResult = !isPaymentCompleted\n                ? await this._stripeUPEClient?.confirmPayment(stripePaymentData)\n                : await this._stripeUPEClient?.retrievePaymentIntent(token || '');\n\n            stripeError = confirmationResult?.error;\n\n            if (stripeError || !confirmationResult?.paymentIntent) {\n                throw new PaymentMethodFailedError();\n            }\n\n            return confirmationResult;\n        } catch (error: unknown) {\n            this.stripeIntegrationService.throwStripeError(stripeError);\n        }\n    }\n\n    private async _processVaultedAdditionalAction(\n        error: unknown,\n        methodId?: string,\n        shouldSetAsDefaultInstrument = false,\n    ): Promise<PaymentIntegrationSelectors | never> {\n        if (\n            !methodId ||\n            !isRequestError(error) ||\n            !some(error.body.errors, { code: 'three_d_secure_required' })\n        ) {\n            throw error;\n        }\n\n        if (!this._stripeUPEClient || !this._stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const clientSecret = error.body.three_ds_result.token;\n        let result;\n        let catchedConfirmError = false;\n\n        try {\n            result = await this._stripeUPEClient.confirmCardPayment(clientSecret);\n        } catch (error) {\n            try {\n                result = await this._stripeUPEClient.retrievePaymentIntent(clientSecret);\n            } catch (error) {\n                catchedConfirmError = true;\n            }\n        }\n\n        if (result?.error) {\n            this.stripeIntegrationService.throwStripeError(result.error);\n        }\n\n        if (!result?.paymentIntent && !catchedConfirmError) {\n            throw new RequestError();\n        }\n\n        const paymentPayload = this._getPaymentPayload(\n            methodId,\n            catchedConfirmError ? clientSecret : result?.paymentIntent?.id,\n            false,\n            shouldSetAsDefaultInstrument,\n        );\n\n        return this.paymentIntegrationService.submitPayment(paymentPayload);\n    }\n\n    private async _loadStripeJs(\n        initializationData: StripeInitializationData,\n    ): Promise<StripeClient> {\n        if (this._stripeUPEClient) {\n            return this._stripeUPEClient;\n        }\n\n        const state = this.paymentIntegrationService.getState();\n\n        return this.scriptLoader.getStripeClient(\n            initializationData,\n            state.getCartLocale(),\n            StripeJsVersion.V3,\n            STRIPE_UPE_CLIENT_BETAS,\n            STRIPE_UPE_CLIENT_API_VERSION,\n        );\n    }\n\n    private _getPaymentPayload(\n        methodId: string,\n        token: string,\n        shouldSaveInstrument = false,\n        shouldSetAsDefaultInstrument = false,\n    ): Payment {\n        const cartId = this.paymentIntegrationService.getState().getCart()?.id || '';\n        const formattedPayload: StripeUPEIntent & FormattedHostedInstrument = {\n            cart_id: cartId,\n            credit_card_token: { token },\n            confirm: false,\n            vault_payment_instrument: shouldSaveInstrument,\n            set_as_default_stored_instrument: shouldSetAsDefaultInstrument,\n        };\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload,\n            },\n        };\n    }\n\n    private _updateStripeElement({ shouldShowTerms }: StripeElementUpdateOptions): void {\n        const stripeElement = this._stripeElements?.getElement(StripeElementType.PAYMENT);\n\n        stripeElement?.update({\n            ...this._getStripeElementTerms(shouldShowTerms),\n        });\n    }\n\n    private _getStripeElementTerms(\n        shouldShowTerms?: boolean,\n    ): Pick<StripeElementsCreateOptions, 'terms'> {\n        let card = StripeStringConstants.AUTO;\n\n        if (this._isStripeElementUpdateEnabled) {\n            card = shouldShowTerms ? StripeStringConstants.AUTO : StripeStringConstants.NEVER;\n        }\n\n        return {\n            terms: {\n                card,\n            },\n        };\n    }\n\n    private _updateStripeLinkStateByElementType(paymentElementType: StripePaymentMethodType): void {\n        const state = this.paymentIntegrationService.getState();\n        const paymentProviderCustomer = state.getPaymentProviderCustomerOrThrow();\n        const isStripeLinkElementType = paymentElementType === StripePaymentMethodType.Link;\n\n        // INFO: Trigger additional update only if Stripe Link Authentication was skipped on the customer step, but the Link payment element was rendered.\n        if (\n            !isStripeAcceleratedCheckoutCustomer(paymentProviderCustomer) &&\n            isStripeLinkElementType\n        ) {\n            this.paymentIntegrationService.updatePaymentProviderCustomer({\n                stripeLinkAuthenticationState: isStripeLinkElementType,\n            });\n        }\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    StripeIntegrationService,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeUPEPaymentStrategy from './stripe-upe-payment-strategy';\n\nconst createStripeUPEPaymentStrategy: PaymentStrategyFactory<StripeUPEPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    const stripeScriptLoader = new StripeScriptLoader(getScriptLoader());\n\n    return new StripeUPEPaymentStrategy(\n        paymentIntegrationService,\n        stripeScriptLoader,\n        new StripeIntegrationService(paymentIntegrationService, stripeScriptLoader),\n    );\n};\n\nexport default toResolvableModule(createStripeUPEPaymentStrategy, [\n    { gateway: 'stripeupe' },\n    { gateway: 'stripeupe', id: 'klarna' },\n]);\n","import { StripePaymentEvent } from './stripe';\n\nexport const isStripePaymentEvent = (event: unknown): event is StripePaymentEvent => {\n    return typeof event === 'object' && event !== null && 'value' in event && 'collapsed' in event;\n};\n","import {\n    InvalidArgumentError,\n    isRequestError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    Payment,\n    PaymentInitializeOptions,\n    PaymentIntegrationSelectors,\n    PaymentIntegrationService,\n    PaymentMethodFailedError,\n    PaymentRequestOptions,\n    PaymentStrategy,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    formatStripeLocale,\n    isStripePaymentEvent,\n    isStripePaymentMethodLike,\n    StripeAdditionalActionRequired,\n    StripeClient,\n    StripeElement,\n    StripeElementEvent,\n    StripeElements,\n    StripeElementType,\n    StripeError,\n    StripeEventType,\n    StripeInitializationData,\n    StripeInstrumentSetupFutureUsage,\n    StripeIntegrationService,\n    StripePIPaymentMethodOptions,\n    StripePIPaymentMethodSavingOptions,\n    StripeResult,\n    StripeScriptLoader,\n    StripeStringConstants,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeOCSPaymentInitializeOptions, {\n    WithStripeOCSPaymentInitializeOptions,\n} from './stripe-ocs-initialize-options';\n\nexport default class StripeOCSPaymentStrategy implements PaymentStrategy {\n    private stripeClient?: StripeClient;\n    private stripeElements?: StripeElements;\n    private selectedMethodId?: string;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n        private stripeIntegrationService: StripeIntegrationService,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithStripeOCSPaymentInitializeOptions,\n    ): Promise<void> {\n        const { stripeocs, methodId, gatewayId } = options;\n\n        if (!stripeocs?.containerId) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!gatewayId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"gatewayId\" argument is not provided.',\n            );\n        }\n\n        try {\n            await this._initializeStripeElement(stripeocs, gatewayId, methodId);\n        } catch (error) {\n            if (error instanceof Error) {\n                stripeocs.onError?.(error);\n            }\n        }\n\n        this.stripeIntegrationService.initCheckoutEventsSubscription(\n            gatewayId,\n            methodId,\n            stripeocs,\n            this.stripeElements,\n        );\n    }\n\n    async execute(orderRequest: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        const { payment, ...order } = orderRequest;\n        const { methodId, gatewayId } = payment || {};\n\n        if (!this.stripeClient) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!gatewayId || !methodId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"gatewayId\" or \"methodId\" argument is not provided.',\n            );\n        }\n\n        const { isStoreCreditApplied } = this.paymentIntegrationService\n            .getState()\n            .getCheckoutOrThrow();\n\n        if (isStoreCreditApplied) {\n            await this.paymentIntegrationService.applyStoreCredit(isStoreCreditApplied);\n        }\n\n        await this.stripeIntegrationService.updateStripePaymentIntent(gatewayId, methodId);\n\n        await this.paymentIntegrationService.submitOrder(order, options);\n\n        const { clientToken } = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow(methodId, gatewayId);\n\n        const paymentPayload = this._getPaymentPayload(methodId, clientToken || '');\n\n        try {\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            await this._processAdditionalAction(error, methodId);\n        }\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    deinitialize(): Promise<void> {\n        const paymentElement = this.stripeElements?.getElement(StripeElementType.PAYMENT);\n\n        paymentElement?.unmount();\n        paymentElement?.destroy();\n        this.stripeIntegrationService.deinitialize();\n        this.stripeElements = undefined;\n        this.stripeClient = undefined;\n\n        return Promise.resolve();\n    }\n\n    private async _initializeStripeElement(\n        stripe: StripeOCSPaymentInitializeOptions,\n        gatewayId: string,\n        methodId: string,\n    ) {\n        let paymentMethod = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow(methodId, gatewayId);\n\n        if (!paymentMethod?.clientToken) {\n            const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n                params: { method: methodId },\n            });\n\n            paymentMethod = state.getPaymentMethodOrThrow(methodId, gatewayId);\n        }\n\n        if (!isStripePaymentMethodLike(paymentMethod)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { clientToken, initializationData } = paymentMethod;\n        const { shopperLanguage, customerSessionToken, enableLink } = initializationData;\n\n        if (!clientToken) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        this.stripeClient = await this._loadStripeJs(initializationData);\n\n        const {\n            appearance,\n            containerId,\n            fonts,\n            layout,\n            render,\n            paymentMethodSelect,\n            handleClosePaymentMethod,\n            togglePreloader,\n        } = stripe;\n\n        this.stripeElements = await this.scriptLoader.getElements(this.stripeClient, {\n            clientSecret: clientToken,\n            customerSessionClientSecret: customerSessionToken,\n            locale: formatStripeLocale(shopperLanguage),\n            appearance,\n            fonts,\n        });\n\n        const { getBillingAddress, getShippingAddress } = this.paymentIntegrationService.getState();\n        const billingAddress = getBillingAddress();\n        const { postalCode } = getShippingAddress() || billingAddress || {};\n\n        const stripeElement: StripeElement =\n            this.stripeElements.getElement(StripeElementType.PAYMENT) ||\n            this.stripeElements.create(StripeElementType.PAYMENT, {\n                fields: {\n                    billingDetails: {\n                        email: StripeStringConstants.NEVER,\n                        address: {\n                            country: StripeStringConstants.NEVER,\n                            city: StripeStringConstants.NEVER,\n                            postalCode: postalCode\n                                ? StripeStringConstants.NEVER\n                                : StripeStringConstants.AUTO,\n                        },\n                    },\n                },\n                wallets: {\n                    applePay: StripeStringConstants.NEVER,\n                    googlePay: StripeStringConstants.NEVER,\n                    link: enableLink ? StripeStringConstants.AUTO : StripeStringConstants.NEVER,\n                },\n                layout,\n                savePaymentMethod: {\n                    maxVisiblePaymentMethods: 20,\n                },\n                defaultValues: {\n                    billingDetails: {\n                        email: billingAddress?.email || '',\n                    },\n                },\n            });\n\n        this.stripeIntegrationService.mountElement(stripeElement, containerId);\n\n        stripeElement.on(StripeElementEvent.LOADER_START, () => {\n            togglePreloader?.(false);\n        });\n\n        stripeElement.on(StripeElementEvent.READY, () => {\n            render();\n        });\n\n        stripeElement.on(StripeElementEvent.CHANGE, (event: StripeEventType) => {\n            this._onStripeElementChange(event, gatewayId, methodId, paymentMethodSelect);\n        });\n\n        handleClosePaymentMethod?.(this._collapseStripeElement.bind(this));\n    }\n\n    private async _loadStripeJs(\n        initializationData: StripeInitializationData,\n    ): Promise<StripeClient> {\n        if (this.stripeClient) {\n            return this.stripeClient;\n        }\n\n        const state = this.paymentIntegrationService.getState();\n        const stripeJsVersion =\n            this.stripeIntegrationService.getStripeJsVersion(initializationData);\n\n        return this.scriptLoader.getStripeClient(\n            initializationData,\n            state.getCartLocale(),\n            stripeJsVersion,\n        );\n    }\n\n    private _collapseStripeElement() {\n        const stripeElement = this.stripeElements?.getElement(StripeElementType.PAYMENT);\n\n        stripeElement?.collapse();\n    }\n\n    private _getPaymentPayload(\n        methodId: string,\n        token: string,\n        paymentMethodOptions?: StripePIPaymentMethodOptions,\n    ): Payment {\n        const cartId = this.paymentIntegrationService.getState().getCart()?.id || '';\n        const { card, us_bank_account } = paymentMethodOptions || {};\n        const shouldSaveInstrument =\n            this._shouldSaveInstrument(card) || this._shouldSaveInstrument(us_bank_account);\n        const tokenizedOptions = this._getTokenizedOptions(token, paymentMethodOptions);\n\n        const formattedPayload = {\n            cart_id: cartId,\n            confirm: false,\n            method: this.selectedMethodId,\n            vault_payment_instrument: shouldSaveInstrument,\n            ...tokenizedOptions,\n        };\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload,\n            },\n        };\n    }\n\n    private async _processAdditionalAction(\n        error: unknown,\n        methodId: string,\n    ): Promise<PaymentIntegrationSelectors | undefined> {\n        if (\n            !isRequestError(error) ||\n            !this.stripeIntegrationService.isAdditionalActionError(error.body.errors)\n        ) {\n            throw error;\n        }\n\n        if (!this.stripeClient || !this.stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { data: additionalActionData } = error.body.additional_action_required;\n        const { token } = additionalActionData;\n\n        const { paymentIntent } = await this._confirmStripePaymentOrThrow(\n            methodId,\n            additionalActionData,\n        );\n        const {\n            client_secret: paymentIntentClientSecret,\n            payment_method_options: paymentMethodOptions,\n        } = paymentIntent || {};\n\n        const paymentPayload = this._getPaymentPayload(\n            methodId,\n            paymentIntentClientSecret || token,\n            paymentMethodOptions,\n        );\n\n        try {\n            return await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            this.stripeIntegrationService.throwPaymentConfirmationProceedMessage();\n        }\n    }\n\n    private async _confirmStripePaymentOrThrow(\n        methodId: string,\n        additionalActionData: StripeAdditionalActionRequired['data'],\n    ): Promise<StripeResult | never> {\n        const { token, redirect_url } = additionalActionData;\n        const stripePaymentData = this.stripeIntegrationService.mapStripePaymentData(\n            this.stripeElements,\n            redirect_url,\n        );\n        let stripeError: StripeError | undefined;\n\n        try {\n            const isPaymentCompleted = await this.stripeIntegrationService.isPaymentCompleted(\n                methodId,\n                this.stripeClient,\n            );\n\n            const confirmationResult = !isPaymentCompleted\n                ? await this.stripeClient?.confirmPayment(stripePaymentData)\n                : await this.stripeClient?.retrievePaymentIntent(token || '');\n\n            stripeError = confirmationResult?.error;\n\n            if (stripeError || !confirmationResult?.paymentIntent) {\n                throw new PaymentMethodFailedError();\n            }\n\n            return confirmationResult;\n        } catch (error: unknown) {\n            return this.stripeIntegrationService.throwStripeError(stripeError);\n        }\n    }\n\n    private _onStripeElementChange(\n        event: StripeEventType,\n        gatewayId: string,\n        methodId: string,\n        paymentMethodSelect?: (id: string) => void,\n    ) {\n        if (!isStripePaymentEvent(event) || event.collapsed) {\n            return;\n        }\n\n        this.selectedMethodId = event.value.type;\n        paymentMethodSelect?.(`${gatewayId}-${methodId}`);\n    }\n\n    private _shouldSaveInstrument(paymentMethodOptions?: StripePIPaymentMethodSavingOptions) {\n        const setupFutureUsage = paymentMethodOptions?.setup_future_usage;\n\n        return (\n            setupFutureUsage === StripeInstrumentSetupFutureUsage.ON_SESSION ||\n            setupFutureUsage === StripeInstrumentSetupFutureUsage.OFF_SESSION\n        );\n    }\n\n    private _getTokenizedOptions(\n        token: string,\n        paymentMethodOptions?: StripePIPaymentMethodOptions,\n    ) {\n        if (this._shouldSaveInstrument(paymentMethodOptions?.us_bank_account)) {\n            return { tokenized_ach: { token } };\n        }\n\n        return { credit_card_token: { token } };\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    StripeIntegrationService,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeOCSPaymentStrategy from './stripe-ocs-payment-strategy';\n\nconst createStripeOCSPaymentStrategy: PaymentStrategyFactory<StripeOCSPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    const stripeScriptLoader = new StripeScriptLoader(getScriptLoader());\n\n    return new StripeOCSPaymentStrategy(\n        paymentIntegrationService,\n        stripeScriptLoader,\n        new StripeIntegrationService(paymentIntegrationService, stripeScriptLoader),\n    );\n};\n\nexport default toResolvableModule(createStripeOCSPaymentStrategy, [\n    { gateway: 'stripeocs', id: 'optimized_checkout' },\n]);\n","import {\n    InvalidArgumentError,\n    isRequestError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    Payment,\n    PaymentInitializeOptions,\n    PaymentIntegrationSelectors,\n    PaymentIntegrationService,\n    PaymentMethodFailedError,\n    PaymentRequestOptions,\n    PaymentStrategy,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    isStripePaymentEvent,\n    isStripePaymentMethodLike,\n    StripeAdditionalActionRequired,\n    StripeCheckoutInstance,\n    StripeCheckoutSession,\n    StripeCheckoutSessionActions,\n    StripeCheckoutSessionPaymentStatus,\n    StripeClient,\n    StripeElement,\n    StripeElementEvent,\n    StripeElementsCreateOptions,\n    StripeEventType,\n    StripeInitializationData,\n    StripeIntegrationService,\n    StripeJsVersion,\n    StripeScriptLoader,\n    StripeStringConstants,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeOCSPaymentInitializeOptions, {\n    WithStripeOCSPaymentInitializeOptions,\n} from '../stripe-ocs/stripe-ocs-initialize-options';\n\nexport default class StripeCSPaymentStrategy implements PaymentStrategy {\n    private stripeClient?: StripeClient;\n    private stripeCheckout?: StripeCheckoutInstance;\n    private selectedMethodId?: string;\n\n    constructor(\n        private readonly paymentIntegrationService: PaymentIntegrationService,\n        private readonly scriptLoader: StripeScriptLoader,\n        private readonly stripeIntegrationService: StripeIntegrationService,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithStripeOCSPaymentInitializeOptions,\n    ): Promise<void> {\n        const { stripeocs, methodId, gatewayId } = options;\n\n        if (!stripeocs?.containerId || !gatewayId) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        try {\n            await this._initializeStripeElement(stripeocs, gatewayId, methodId);\n        } catch (error) {\n            if (error instanceof Error) {\n                stripeocs.onError?.(error);\n            }\n        }\n    }\n\n    async execute(orderRequest: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        const { payment, ...order } = orderRequest;\n        const { methodId, gatewayId } = payment || {};\n\n        if (!this.stripeClient) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        if (!gatewayId || !methodId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"gatewayId\" or \"methodId\" argument is not provided.',\n            );\n        }\n\n        const state = this.paymentIntegrationService.getState();\n        const { isStoreCreditApplied } = state.getCheckoutOrThrow();\n\n        if (isStoreCreditApplied) {\n            await this.paymentIntegrationService.applyStoreCredit(isStoreCreditApplied);\n        }\n\n        await this._updateCheckoutSessionData(gatewayId, methodId);\n\n        await this.paymentIntegrationService.submitOrder(order, options);\n\n        const { clientToken } = state.getPaymentMethodOrThrow(methodId);\n        const paymentPayload = this._getPaymentPayload(methodId, clientToken || '');\n\n        try {\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            await this._processAdditionalAction(error, methodId);\n        }\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    deinitialize(): Promise<void> {\n        const paymentElement = this.stripeCheckout?.getPaymentElement();\n\n        paymentElement?.unmount();\n        paymentElement?.destroy();\n        this.stripeCheckout = undefined;\n        this.stripeClient = undefined;\n        this.selectedMethodId = undefined;\n\n        return Promise.resolve();\n    }\n\n    private async _initializeStripeElement(\n        stripe: StripeOCSPaymentInitializeOptions,\n        gatewayId: string,\n        methodId: string,\n    ) {\n        let paymentMethod = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow<StripeInitializationData>(methodId, gatewayId);\n\n        if (!paymentMethod?.clientToken) {\n            const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n                params: { method: methodId },\n            });\n\n            paymentMethod = state.getPaymentMethodOrThrow<StripeInitializationData>(\n                methodId,\n                gatewayId,\n            );\n        }\n\n        if (!isStripePaymentMethodLike(paymentMethod)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { clientToken, initializationData } = paymentMethod;\n\n        if (!clientToken) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        this.stripeClient = await this._loadStripeJs(initializationData);\n\n        const { enableLink } = initializationData;\n        const {\n            appearance,\n            containerId,\n            fonts,\n            layout,\n            render,\n            paymentMethodSelect,\n            handleClosePaymentMethod,\n            togglePreloader,\n        } = stripe;\n\n        const { getBillingAddress, getShippingAddress } = this.paymentIntegrationService.getState();\n        const billingAddress = getBillingAddress();\n        const { postalCode } = getShippingAddress() || billingAddress || {};\n\n        this.stripeCheckout = await this.scriptLoader.getStripeCheckout(this.stripeClient, {\n            clientSecret: clientToken,\n            elementsOptions: {\n                appearance,\n                fonts,\n            },\n            adaptivePricing: {\n                allowed: false,\n            },\n        });\n\n        const stripeActions = await this._getStripeActionsOrThrow();\n\n        await stripeActions.updateEmail(billingAddress?.email || '');\n\n        const stripeElement = this._getStripeElement({\n            fields: {\n                billingDetails: {\n                    email: StripeStringConstants.NEVER,\n                    address: {\n                        country: StripeStringConstants.NEVER,\n                        city: StripeStringConstants.NEVER,\n                        postalCode: postalCode\n                            ? StripeStringConstants.NEVER\n                            : StripeStringConstants.AUTO,\n                    },\n                },\n            },\n            wallets: {\n                applePay: StripeStringConstants.NEVER,\n                googlePay: StripeStringConstants.NEVER,\n                link: enableLink ? StripeStringConstants.AUTO : StripeStringConstants.NEVER,\n            },\n            layout,\n        });\n\n        if (!stripeElement) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        this.stripeIntegrationService.mountElement(stripeElement, containerId);\n\n        stripeElement.on(StripeElementEvent.LOADER_START, () => {\n            togglePreloader?.(false);\n        });\n\n        stripeElement.on(StripeElementEvent.READY, () => {\n            render();\n        });\n\n        stripeElement.on(StripeElementEvent.CHANGE, (event: StripeEventType) => {\n            this._onStripeElementChange(event, gatewayId, methodId, paymentMethodSelect);\n        });\n\n        handleClosePaymentMethod?.(this._collapseStripeElement.bind(this));\n    }\n\n    private async _loadStripeJs(\n        initializationData: StripeInitializationData,\n    ): Promise<StripeClient> {\n        if (this.stripeClient) {\n            return this.stripeClient;\n        }\n\n        const state = this.paymentIntegrationService.getState();\n\n        return this.scriptLoader.getStripeClient(\n            initializationData,\n            state.getCartLocale(),\n            StripeJsVersion.CLOVER,\n        );\n    }\n\n    private async _getStripeActionsOrThrow(): Promise<StripeCheckoutSessionActions> {\n        if (!this.stripeCheckout) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { actions, error } = await this.stripeCheckout.loadActions();\n\n        if (!actions || error) {\n            throw new PaymentMethodFailedError(error?.message);\n        }\n\n        return actions;\n    }\n\n    private _getStripeElement(options?: StripeElementsCreateOptions): StripeElement | undefined {\n        return (\n            this.stripeCheckout?.getPaymentElement() ||\n            this.stripeCheckout?.createPaymentElement(options)\n        );\n    }\n\n    private _onStripeElementChange(\n        event: StripeEventType,\n        gatewayId: string,\n        methodId: string,\n        paymentMethodSelect?: (id: string) => void,\n    ) {\n        if (!isStripePaymentEvent(event) || event.collapsed) {\n            return;\n        }\n\n        this.selectedMethodId = event.value.type;\n        paymentMethodSelect?.(`${gatewayId}-${methodId}`);\n    }\n\n    private _collapseStripeElement() {\n        const stripeElement = this.stripeCheckout?.getPaymentElement();\n\n        stripeElement?.collapse();\n    }\n\n    private async _updateCheckoutSessionData(gatewayId: string, methodId: string): Promise<void> {\n        // INFO: to trigger checkout session data update on the BE side we need to make stripe config request\n        await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n    }\n\n    private _getPaymentPayload(methodId: string, token: string): Payment {\n        const cartId = this.paymentIntegrationService.getState().getCart()?.id || '';\n\n        const formattedPayload = {\n            cart_id: cartId,\n            confirm: false,\n            method: this.selectedMethodId,\n            credit_card_token: { token },\n        };\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload,\n            },\n        };\n    }\n\n    private async _processAdditionalAction(\n        error: unknown,\n        methodId: string,\n    ): Promise<PaymentIntegrationSelectors | undefined> {\n        if (\n            !isRequestError(error) ||\n            !this.stripeIntegrationService.isAdditionalActionError(error.body.errors)\n        ) {\n            throw error;\n        }\n\n        const { data: additionalActionData } = error.body?.additional_action_required || {};\n        const { token } = additionalActionData || {};\n\n        const { id: checkoutSessionId, status: checkoutSessionStatus } =\n            await this._confirmStripePaymentOrThrow(additionalActionData);\n\n        const paymentPayload = this._getPaymentPayload(methodId, checkoutSessionId || token);\n\n        try {\n            return await this.paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            if (checkoutSessionStatus.paymentStatus === StripeCheckoutSessionPaymentStatus.Paid) {\n                this.stripeIntegrationService.throwPaymentConfirmationProceedMessage();\n            }\n\n            throw error;\n        }\n    }\n\n    private async _confirmStripePaymentOrThrow(\n        additionalActionData: StripeAdditionalActionRequired['data'],\n    ): Promise<StripeCheckoutSession | never> {\n        const { redirect_url } = additionalActionData || {};\n\n        if (!this.stripeCheckout) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const stripeActions = await this._getStripeActionsOrThrow();\n\n        const { session: stripeCheckoutSession, error: stripeError } = await stripeActions.confirm({\n            redirect: StripeStringConstants.IF_REQUIRED,\n            returnUrl: redirect_url,\n        });\n\n        if (stripeError || !stripeCheckoutSession) {\n            throw new PaymentMethodFailedError(stripeError?.message);\n        }\n\n        return stripeCheckoutSession;\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    StripeIntegrationService,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeCSPaymentStrategy from './stripe-cs-payment-strategy';\n\nconst createStripeCSPaymentStrategy: PaymentStrategyFactory<StripeCSPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    const stripeScriptLoader = new StripeScriptLoader(getScriptLoader());\n\n    return new StripeCSPaymentStrategy(\n        paymentIntegrationService,\n        stripeScriptLoader,\n        new StripeIntegrationService(paymentIntegrationService, stripeScriptLoader),\n    );\n};\n\nexport default toResolvableModule(createStripeCSPaymentStrategy, [\n    { gateway: 'stripeocs', id: 'checkout_session' },\n]);\n","import {\n    CustomerCredentials,\n    CustomerInitializeOptions,\n    CustomerStrategy,\n    ExecutePaymentMethodCheckoutOptions,\n    InvalidArgumentError,\n    MissingDataError,\n    MissingDataErrorType,\n    PaymentIntegrationService,\n    RequestOptions,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    isStripePaymentMethodLike,\n    STRIPE_UPE_CLIENT_API_VERSION,\n    STRIPE_UPE_CLIENT_BETAS,\n    StripeAppearanceOptions,\n    StripeClient,\n    StripeElementEvent,\n    StripeElements,\n    StripeElementType,\n    StripeEventType,\n    StripeFormMode,\n    StripeJsVersion,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport isStripeAcceleratedCheckoutCustomer from './is-stripe-accelerated-checkout-customer';\nimport { WithStripeUPECustomerInitializeOptions } from './stripeupe-customer-initialize-options';\n\nexport default class StripeUPECustomerStrategy implements CustomerStrategy {\n    private _stripeElements?: StripeElements;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n    ) {}\n\n    async initialize(\n        options: CustomerInitializeOptions & WithStripeUPECustomerInitializeOptions,\n    ): Promise<void> {\n        let stripeUPEClient: StripeClient;\n\n        if (!options.stripeupe) {\n            throw new InvalidArgumentError(\n                `Unable to proceed because \"options\" argument is not provided.`,\n            );\n        }\n\n        const { container, gatewayId, methodId, onEmailChange, getStyles, isLoading } =\n            options.stripeupe;\n\n        Object.entries(options.stripeupe).forEach(([key, value]) => {\n            if (!value) {\n                throw new InvalidArgumentError(\n                    `Unable to proceed because \"${key}\" argument is not provided.`,\n                );\n            }\n        });\n\n        await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n\n        const state = this.paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId, gatewayId);\n        const { clientToken } = paymentMethod;\n\n        if (!isStripePaymentMethodLike(paymentMethod) || !clientToken) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentToken);\n        }\n\n        const { email } = state.getCustomerOrThrow();\n        const paymentProviderCustomer = state.getPaymentProviderCustomerOrThrow();\n        const stripePaymentProviderCustomer = isStripeAcceleratedCheckoutCustomer(\n            paymentProviderCustomer,\n        )\n            ? paymentProviderCustomer\n            : {};\n        const stripeLinkAuthenticationState =\n            stripePaymentProviderCustomer.stripeLinkAuthenticationState;\n\n        if (!email) {\n            let appearance: StripeAppearanceOptions | undefined;\n            const styles = typeof getStyles === 'function' && getStyles();\n\n            if (styles) {\n                appearance = {\n                    variables: {\n                        colorPrimary: styles.fieldInnerShadow,\n                        colorBackground: styles.fieldBackground,\n                        colorText: styles.labelText,\n                        colorDanger: styles.fieldErrorText,\n                        colorTextSecondary: styles.labelText,\n                        colorTextPlaceholder: styles.fieldPlaceholderText,\n                    },\n                    rules: {\n                        '.Input': {\n                            borderColor: styles.fieldBorder,\n                            color: styles.fieldText,\n                            boxShadow: styles.fieldInnerShadow,\n                        },\n                    },\n                };\n            } else {\n                appearance = {};\n            }\n\n            stripeUPEClient = await this.scriptLoader.getStripeClient(\n                paymentMethod.initializationData,\n                state.getCartLocale(),\n                StripeJsVersion.V3,\n                STRIPE_UPE_CLIENT_BETAS,\n                STRIPE_UPE_CLIENT_API_VERSION,\n            );\n\n            this._stripeElements = await this.scriptLoader.getElements(stripeUPEClient, {\n                clientSecret: clientToken,\n                appearance,\n            });\n\n            const { getBillingAddress, getConsignments } =\n                this.paymentIntegrationService.getState();\n            const consignments = getConsignments();\n            const id = consignments?.[0]?.id;\n            const { email: billingEmail } = getBillingAddress() || {};\n            const options = billingEmail\n                ? { defaultValues: { mode: StripeFormMode.SHIPPING, email: billingEmail } }\n                : {};\n            const linkAuthenticationElement =\n                this._stripeElements.getElement(StripeElementType.AUTHENTICATION) ||\n                this._stripeElements.create(StripeElementType.AUTHENTICATION, options);\n\n            linkAuthenticationElement.on(StripeElementEvent.CHANGE, (event: StripeEventType) => {\n                if (!('authenticated' in event)) {\n                    throw new MissingDataError(MissingDataErrorType.MissingCustomer);\n                }\n\n                this.paymentIntegrationService.updatePaymentProviderCustomer({\n                    stripeLinkAuthenticationState: event.authenticated,\n                });\n\n                if (event.complete) {\n                    onEmailChange(event.authenticated, event.value.email);\n                } else {\n                    onEmailChange(false, '');\n                }\n\n                if (isLoading) {\n                    isLoading(false);\n                }\n\n                if (stripeLinkAuthenticationState === undefined && event.authenticated && id) {\n                    this.paymentIntegrationService.deleteConsignment(id);\n                }\n            });\n            linkAuthenticationElement.mount(`#${container}`);\n        }\n    }\n\n    deinitialize(): Promise<void> {\n        this._stripeElements?.getElement(StripeElementType.AUTHENTICATION)?.unmount();\n\n        return Promise.resolve();\n    }\n\n    signIn(credentials: CustomerCredentials, options?: RequestOptions): Promise<void> {\n        this.paymentIntegrationService.signInCustomer(credentials, options);\n\n        return Promise.resolve();\n    }\n\n    signOut(options?: RequestOptions): Promise<void> {\n        this.paymentIntegrationService.signOutCustomer(options);\n\n        return Promise.resolve();\n    }\n\n    executePaymentMethodCheckout(options?: ExecutePaymentMethodCheckoutOptions): Promise<void> {\n        options?.continueWithCheckoutCallback?.();\n\n        return Promise.resolve();\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    CustomerStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport { StripeScriptLoader } from '@bigcommerce/checkout-sdk/stripe-utils';\n\nimport StripeUPECustomerStrategy from './stripe-upe-customer-strategy';\n\nconst createStripeUPECustomerStrategy: CustomerStrategyFactory<StripeUPECustomerStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new StripeUPECustomerStrategy(\n        paymentIntegrationService,\n        new StripeScriptLoader(getScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createStripeUPECustomerStrategy, [{ id: 'stripeupe' }]);\n","import {\n    LoadingIndicatorContainerStyles,\n    LoadingIndicatorStyles,\n} from './loading-indicator-styles';\n\nconst DEFAULT_STYLES: LoadingIndicatorStyles = {\n    size: 70,\n    color: '#d9d9d9',\n    backgroundColor: '#ffffff',\n};\n\nexport const DEFAULT_CONTAINER_STYLES = {\n    position: 'fixed',\n    'background-color': 'rgba(0, 0, 0, 0.4)',\n    'z-index': '1000',\n};\n\nconst ROTATION_ANIMATION = 'embedded-checkout-loading-indicator-rotation';\n\ninterface LoadingIndicatorOptions {\n    styles?: LoadingIndicatorStyles;\n    containerStyles?: LoadingIndicatorContainerStyles;\n}\n\nexport default class LoadingIndicator {\n    private container: HTMLElement;\n    private indicator: HTMLElement;\n    private styles: LoadingIndicatorStyles;\n    private containerStyles: LoadingIndicatorContainerStyles;\n\n    constructor(options?: LoadingIndicatorOptions) {\n        this.styles = { ...DEFAULT_STYLES, ...(options && options.styles) };\n        this.containerStyles = { ...(options && options.containerStyles) };\n\n        this.defineAnimation();\n\n        this.container = this.buildContainer();\n        this.indicator = this.buildIndicator();\n\n        this.container.appendChild(this.indicator);\n    }\n\n    show(parentId?: string): void {\n        if (parentId) {\n            const parent = document.getElementById(parentId);\n\n            if (!parent) {\n                throw new Error(\n                    'Unable to attach the loading indicator because the parent ID is not valid.',\n                );\n            }\n\n            parent.appendChild(this.container);\n        }\n\n        this.container.style.visibility = 'visible';\n        this.container.style.opacity = '1';\n    }\n\n    hide(): void {\n        const handleTransitionEnd = () => {\n            this.container.style.visibility = 'hidden';\n\n            this.container.removeEventListener('transitionend', handleTransitionEnd);\n        };\n\n        this.container.addEventListener('transitionend', handleTransitionEnd);\n\n        this.container.style.opacity = '0';\n    }\n\n    private buildContainer(): HTMLElement {\n        const container = document.createElement('div');\n\n        container.style.display = 'block';\n        container.style.bottom = '0';\n        container.style.left = '0';\n        container.style.height = '100%';\n        container.style.width = '100%';\n        container.style.position = 'absolute';\n        container.style.right = '0';\n        container.style.top = '0';\n        container.style.transition = 'all 250ms ease-out';\n        container.style.opacity = '0';\n\n        this.setStyleAttribute(container, this.containerStyles);\n\n        return container;\n    }\n\n    private buildIndicator(): HTMLElement {\n        const indicator = document.createElement('div');\n\n        indicator.style.display = 'block';\n        indicator.style.width = `${this.styles.size}px`;\n        indicator.style.height = `${this.styles.size}px`;\n        indicator.style.borderRadius = `${this.styles.size}px`;\n        indicator.style.border = 'solid 1px';\n        indicator.style.borderColor = `${this.styles.backgroundColor} ${this.styles.backgroundColor} ${this.styles.color} ${this.styles.color}`;\n        indicator.style.margin = '0 auto';\n        indicator.style.position = 'absolute';\n        indicator.style.left = '0';\n        indicator.style.right = '0';\n        indicator.style.top = '50%';\n        indicator.style.transform = 'translateY(-50%) rotate(0deg)';\n        indicator.style.transformStyle = 'preserve-3d';\n        indicator.style.animation = `${ROTATION_ANIMATION} 500ms infinite cubic-bezier(0.69, 0.31, 0.56, 0.83)`;\n\n        return indicator;\n    }\n\n    private setStyleAttribute(element: HTMLElement, attrs: { [key: string]: string }): void {\n        Object.keys(attrs).forEach((k) => {\n            element.style.setProperty(k, attrs[k]);\n        });\n    }\n\n    private defineAnimation(): void {\n        // In order to define CSS animation, we need to insert a stylesheet into the host frame.\n        // We only have to do it once.\n        if (document.getElementById(ROTATION_ANIMATION)) {\n            return;\n        }\n\n        const style = document.createElement('style');\n\n        style.id = ROTATION_ANIMATION;\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        document.head?.appendChild(style);\n\n        if (style.sheet instanceof CSSStyleSheet) {\n            // We need to provide the 2nd parameter for IE11, even though it is\n            // 0 by default for all other browsers.\n            style.sheet.insertRule(\n                `\n                @keyframes ${ROTATION_ANIMATION} {\n                    0% { transform: translateY(-50%) rotate(0deg); }\n                    100% { transform: translateY(-50%) rotate(360deg); }\n                }\n            `,\n                0,\n            );\n        }\n    }\n}\n","export default class AmountTransformer {\n    constructor(private _decimalPlaces: number) {}\n\n    toInteger(amount: number): number {\n        return Math.round(amount * 10 ** this._decimalPlaces);\n    }\n}\n","export const expressCheckoutAllowedCountryCodes = [\n    'AC',\n    'AD',\n    'AE',\n    'AF',\n    'AG',\n    'AI',\n    'AL',\n    'AM',\n    'AO',\n    'AQ',\n    'AR',\n    'AT',\n    'AU',\n    'AW',\n    'AX',\n    'AZ',\n    'BA',\n    'BB',\n    'BD',\n    'BE',\n    'BF',\n    'BG',\n    'BH',\n    'BI',\n    'BJ',\n    'BL',\n    'BM',\n    'BN',\n    'BO',\n    'BQ',\n    'BR',\n    'BS',\n    'BT',\n    'BV',\n    'BW',\n    'BY',\n    'BZ',\n    'CA',\n    'CD',\n    'CF',\n    'CG',\n    'CH',\n    'CI',\n    'CK',\n    'CL',\n    'CM',\n    'CN',\n    'CO',\n    'CR',\n    'CV',\n    'CW',\n    'CY',\n    'CZ',\n    'DE',\n    'DJ',\n    'DK',\n    'DM',\n    'DO',\n    'DZ',\n    'EC',\n    'EE',\n    'EG',\n    'EH',\n    'ER',\n    'ES',\n    'ET',\n    'FI',\n    'FJ',\n    'FK',\n    'FO',\n    'FR',\n    'GA',\n    'GB',\n    'GD',\n    'GE',\n    'GF',\n    'GG',\n    'GH',\n    'GI',\n    'GL',\n    'GM',\n    'GN',\n    'GP',\n    'GQ',\n    'GR',\n    'GS',\n    'GT',\n    'GU',\n    'GW',\n    'GY',\n    'HK',\n    'HN',\n    'HR',\n    'HT',\n    'HU',\n    'ID',\n    'IE',\n    'IL',\n    'IM',\n    'IN',\n    'IO',\n    'IQ',\n    'IS',\n    'IT',\n    'JE',\n    'JM',\n    'JO',\n    'JP',\n    'KE',\n    'KG',\n    'KH',\n    'KI',\n    'KM',\n    'KN',\n    'KR',\n    'KW',\n    'KY',\n    'KZ',\n    'LA',\n    'LB',\n    'LC',\n    'LI',\n    'LK',\n    'LR',\n    'LS',\n    'LT',\n    'LU',\n    'LV',\n    'LY',\n    'MA',\n    'MC',\n    'MD',\n    'ME',\n    'MF',\n    'MG',\n    'MK',\n    'ML',\n    'MM',\n    'MN',\n    'MO',\n    'MQ',\n    'MR',\n    'MS',\n    'MT',\n    'MU',\n    'MV',\n    'MW',\n    'MX',\n    'MY',\n    'MZ',\n    'NA',\n    'NC',\n    'NE',\n    'NG',\n    'NI',\n    'NL',\n    'NO',\n    'NP',\n    'NR',\n    'NU',\n    'NZ',\n    'OM',\n    'PA',\n    'PE',\n    'PF',\n    'PG',\n    'PH',\n    'PK',\n    'PL',\n    'PM',\n    'PN',\n    'PR',\n    'PS',\n    'PT',\n    'PY',\n    'QA',\n    'RE',\n    'RO',\n    'RS',\n    'RU',\n    'RW',\n    'SA',\n    'SB',\n    'SC',\n    'SD',\n    'SE',\n    'SG',\n    'SH',\n    'SI',\n    'SJ',\n    'SK',\n    'SL',\n    'SM',\n    'SN',\n    'SO',\n    'SR',\n    'SS',\n    'ST',\n    'SV',\n    'SX',\n    'SZ',\n    'TA',\n    'TC',\n    'TD',\n    'TF',\n    'TG',\n    'TH',\n    'TJ',\n    'TK',\n    'TL',\n    'TM',\n    'TN',\n    'TO',\n    'TR',\n    'TT',\n    'TV',\n    'TW',\n    'TZ',\n    'UA',\n    'UG',\n    'US',\n    'UY',\n    'UZ',\n    'VA',\n    'VC',\n    'VE',\n    'VG',\n    'VN',\n    'VU',\n    'WF',\n    'WS',\n    'XK',\n    'YE',\n    'YT',\n    'ZA',\n    'ZM',\n    'ZW',\n    'ZZ',\n];\n","import { round } from 'lodash';\n\nimport {\n    AmountTransformer,\n    CustomerInitializeOptions,\n    CustomerStrategy,\n    InvalidArgumentError,\n    isRequestError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    Payment,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodFailedError,\n    ShippingOption,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    isStripePaymentMethodLike,\n    StripeAdditionalActionRequired,\n    StripeClient,\n    StripeElement,\n    StripeElementEvent,\n    StripeElements,\n    StripeElementsCreateOptions,\n    StripeElementType,\n    StripeError,\n    StripeEventType,\n    StripeIntegrationService,\n    StripeLinkV2Event,\n    StripeLinkV2Options,\n    StripeLinkV2ShippingRate,\n    StripePaymentMethodType,\n    StripeResult,\n    StripeScriptLoader,\n    StripeStringConstants,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\nimport { LoadingIndicator } from '@bigcommerce/checkout-sdk/ui';\n\nimport { expressCheckoutAllowedCountryCodes } from './constants';\nimport { WithStripeOCSCustomerInitializeOptions } from './stripe-ocs-customer-initialize-options';\n\nexport default class StripeLinkV2CustomerStrategy implements CustomerStrategy {\n    private _stripeClient?: StripeClient;\n    private _stripeElements?: StripeElements;\n    private _linkV2Element?: StripeElement;\n    private _amountTransformer?: AmountTransformer;\n    private _onComplete?: (orderId?: number) => Promise<never>;\n    private _loadingIndicatorContainer?: string;\n    private _captureMethod?: 'automatic' | 'manual';\n    private _currencyCode?: string;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n        private stripeIntegrationService: StripeIntegrationService,\n        private loadingIndicator: LoadingIndicator,\n    ) {}\n\n    async initialize(\n        options: CustomerInitializeOptions & WithStripeOCSCustomerInitializeOptions,\n    ): Promise<void> {\n        const { stripeocs } = options || {};\n\n        if (!stripeocs) {\n            throw new InvalidArgumentError(\n                `Unable to proceed because \"options\" argument is not provided.`,\n            );\n        }\n\n        const { methodId, gatewayId, container } = stripeocs;\n\n        if (!container || !methodId || !gatewayId) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId, gatewayId);\n        const { loadingContainerId, buttonHeight, onComplete } = stripeocs;\n\n        this._loadingIndicatorContainer = loadingContainerId;\n\n        this._onComplete = onComplete;\n\n        if (!isStripePaymentMethodLike(paymentMethod)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { initializationData } = paymentMethod;\n        const { captureMethod } = initializationData;\n        const stripeJsVersion =\n            this.stripeIntegrationService.getStripeJsVersion(initializationData);\n\n        this._captureMethod = captureMethod;\n        this._stripeClient = await this.scriptLoader.getStripeClient(\n            initializationData,\n            state.getCartLocale(),\n            stripeJsVersion,\n        );\n\n        await this._mountExpressCheckoutElement(container, this._stripeClient, buttonHeight);\n\n        this._initializeEvents(methodId);\n    }\n\n    signIn() {\n        return Promise.resolve();\n    }\n\n    signOut() {\n        return Promise.resolve();\n    }\n\n    executePaymentMethodCheckout() {\n        return Promise.resolve();\n    }\n\n    deinitialize() {\n        return Promise.resolve();\n    }\n\n    private async _mountExpressCheckoutElement(\n        container: string,\n        stripeExpressCheckoutClient: StripeClient,\n        buttonHeight = 40,\n    ) {\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n        const expressCheckoutOptions: StripeElementsCreateOptions = {\n            shippingAddressRequired: shouldRequireShippingAddress,\n            ...(shouldRequireShippingAddress\n                ? { allowedShippingCountries: await this._getAvailableCountries() }\n                : {}),\n            ...(shouldRequireShippingAddress\n                ? { shippingRates: [{ id: '_', amount: 0, displayName: 'Pending rates' }] }\n                : {}),\n            billingAddressRequired: true,\n            emailRequired: true,\n            phoneNumberRequired: true,\n            paymentMethods: {\n                link: StripeStringConstants.AUTO,\n                applePay: StripeStringConstants.NEVER,\n                googlePay: StripeStringConstants.NEVER,\n                amazonPay: StripeStringConstants.NEVER,\n                paypal: StripeStringConstants.NEVER,\n                klarna: StripeStringConstants.NEVER,\n            },\n            // Minimal buttonHeight value is 40\n            buttonHeight,\n        };\n\n        const { cartAmount } = this.paymentIntegrationService.getState().getCartOrThrow();\n\n        const elementsOptions: StripeLinkV2Options = {\n            mode: 'payment',\n            amount: this._toCents(cartAmount),\n            currency: this._getCurrency(),\n            ...(this._captureMethod ? { captureMethod: this._captureMethod } : {}),\n        };\n\n        this._stripeElements = stripeExpressCheckoutClient.elements(elementsOptions);\n\n        this._linkV2Element = this._stripeElements.create(\n            StripeElementType.EXPRESS_CHECKOUT,\n            expressCheckoutOptions,\n        );\n        this._linkV2Element.mount(`#${container}`);\n\n        return this._linkV2Element;\n    }\n\n    /** Events * */\n\n    private _initializeEvents(methodId: string): void {\n        if (!this._linkV2Element) {\n            return;\n        }\n\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n\n        if (shouldRequireShippingAddress) {\n            this._linkV2Element.on(StripeElementEvent.SHIPPING_ADDRESS_CHANGE, async (event) =>\n                this._onShippingAddressChange(event),\n            );\n            this._linkV2Element.on(StripeElementEvent.SHIPPING_RATE_CHANGE, async (event) =>\n                this._onShippingRateChange(event),\n            );\n        }\n\n        this._linkV2Element.on(StripeElementEvent.CONFIRM, async (event) =>\n            this._onConfirm(event, methodId),\n        );\n\n        this._linkV2Element.on(StripeElementEvent.CANCEL, this._onCancel);\n    }\n\n    private async _onShippingAddressChange(event: StripeEventType): Promise<void> {\n        if (!('address' in event)) {\n            return;\n        }\n\n        const shippingAddress = event.address;\n        // Depending on the country, some fields can be missing or partially redacted.\n        // For example, the shipping address in the US can only contain a city, state, and ZIP code.\n        // The full shipping address appears in the confirm event object after the purchase is confirmed in the browsers payment interface.\n        const result = {\n            firstName: '',\n            lastName: '',\n            phone: '',\n            company: '',\n            address1: '',\n            address2: '',\n            city: shippingAddress?.city || '',\n            countryCode: shippingAddress?.country || '',\n            postalCode: shippingAddress?.postal_code || '',\n            stateOrProvince: shippingAddress?.state || '',\n            stateOrProvinceCode: shippingAddress?.state || '',\n            customFields: [],\n        };\n\n        await this.paymentIntegrationService.updateShippingAddress(result);\n\n        const shippingRates = await this._getAvailableShippingOptions();\n\n        await this._updateDisplayedPrice();\n\n        if (!shippingRates?.length) {\n            event.reject();\n        } else {\n            event.resolve({\n                shippingRates,\n            });\n        }\n    }\n\n    private _onCancel() {\n        throw new PaymentMethodCancelledError();\n    }\n\n    private async _onShippingRateChange(event: StripeEventType) {\n        if ('shippingRate' in event) {\n            const { shippingRate } = event;\n\n            await this._handleShippingOptionChange(shippingRate?.id);\n\n            await this._updateDisplayedPrice();\n\n            event.resolve({});\n        }\n    }\n\n    /** Confirm methods * */\n    private async _onConfirm(event: StripeEventType, methodId: string) {\n        if (\n            'billingDetails' in event &&\n            'shippingAddress' in event &&\n            this._stripeClient &&\n            this._stripeElements\n        ) {\n            await this._updateShippingAndBillingAddress(event);\n            await this.paymentIntegrationService.submitOrder();\n\n            const paymentPayload = this._getPaymentPayload(methodId);\n\n            try {\n                await this.paymentIntegrationService.submitPayment(paymentPayload);\n            } catch (error) {\n                await this._processAdditionalAction(error, methodId);\n            }\n        }\n\n        return Promise.resolve();\n    }\n\n    private async _updateShippingAndBillingAddress(event: StripeLinkV2Event) {\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n\n        const firstName =\n            event.shippingAddress?.name?.split(' ')[0] ||\n            event.billingDetails?.name?.split(' ')[0] ||\n            '';\n        const lastName =\n            event.shippingAddress?.name?.split(' ')[1] ||\n            event.billingDetails?.name?.split(' ')[1] ||\n            '';\n\n        if (shouldRequireShippingAddress) {\n            const shippingAddress = this._mapShippingAddress(\n                event.shippingAddress,\n                event.billingDetails,\n                firstName,\n                lastName,\n            );\n\n            await this.paymentIntegrationService.updateShippingAddress(shippingAddress);\n        }\n\n        const billingAddress = this._mapBillingAddress(\n            event.shippingAddress,\n            event.billingDetails,\n            firstName,\n            lastName,\n        );\n\n        await this.paymentIntegrationService.updateBillingAddress(billingAddress);\n    }\n\n    private _mapShippingAddress(\n        shippingAddress: StripeLinkV2Event['shippingAddress'],\n        billingDetails: StripeLinkV2Event['billingDetails'],\n        firstName: string,\n        lastName: string,\n    ) {\n        return {\n            firstName,\n            lastName,\n            phone: billingDetails?.phone || '',\n            company: '',\n            address1: shippingAddress?.address?.line1 || '',\n            address2: shippingAddress?.address?.line2 || '',\n            city: shippingAddress?.address?.city || '',\n            countryCode: shippingAddress?.address?.country || '',\n            postalCode: shippingAddress?.address?.postal_code || '',\n            stateOrProvince: shippingAddress?.address?.state || '',\n            stateOrProvinceCode: shippingAddress?.address?.state || '',\n            customFields: [],\n        };\n    }\n\n    private _mapBillingAddress(\n        shippingAddress: StripeLinkV2Event['shippingAddress'],\n        billingDetails: StripeLinkV2Event['billingDetails'],\n        firstName: string,\n        lastName: string,\n    ) {\n        return {\n            email: billingDetails?.email || '',\n            firstName,\n            lastName,\n            phone: billingDetails?.phone || '',\n            company: '',\n            address1: billingDetails?.address?.line1 || '',\n            address2: '',\n            city: billingDetails?.address?.city || '',\n            countryCode: billingDetails?.address?.country || '',\n            postalCode: billingDetails?.address?.postal_code || '',\n            stateOrProvince: billingDetails?.address?.state || '',\n            stateOrProvinceCode: shippingAddress?.address?.state || '',\n            customFields: [],\n        };\n    }\n\n    private async _processAdditionalAction(error: unknown, methodId: string): Promise<void> {\n        if (\n            !isRequestError(error) ||\n            !this.stripeIntegrationService.isAdditionalActionError(error.body.errors)\n        ) {\n            throw error;\n        }\n\n        if (!this._stripeClient || !this._stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { data: additionalActionData } = error.body.additional_action_required;\n        const { token } = additionalActionData;\n\n        const { paymentIntent } = await this._confirmStripePaymentOrThrow(\n            additionalActionData,\n            methodId,\n        );\n\n        const paymentPayload = this._getPaymentPayload(methodId, paymentIntent?.id || token);\n\n        try {\n            this._toggleLoadingIndicator(true);\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n            await this._completeCheckoutFlow();\n        } catch (error) {\n            this.stripeIntegrationService.throwPaymentConfirmationProceedMessage();\n        } finally {\n            this._toggleLoadingIndicator(false);\n        }\n    }\n\n    private async _confirmStripePaymentOrThrow(\n        additionalActionData: StripeAdditionalActionRequired['data'],\n        methodId: string,\n    ): Promise<StripeResult | never> {\n        const { token, redirect_url } = additionalActionData;\n        const stripePaymentData = this.stripeIntegrationService.mapStripePaymentData(\n            this._stripeElements,\n            redirect_url,\n        );\n        let stripeError: StripeError | undefined;\n\n        try {\n            const isPaymentCompleted = await this.stripeIntegrationService.isPaymentCompleted(\n                methodId,\n                this._stripeClient,\n            );\n\n            const confirmationResult = !isPaymentCompleted\n                ? await this._stripeClient?.confirmPayment({\n                      elements: stripePaymentData.elements,\n                      clientSecret: token,\n                      redirect: StripeStringConstants.IF_REQUIRED,\n                      confirmParams: {\n                          return_url: stripePaymentData.confirmParams?.return_url,\n                      },\n                  })\n                : await this._stripeClient?.retrievePaymentIntent(token || '');\n\n            stripeError = confirmationResult?.error;\n\n            if (stripeError || !confirmationResult?.paymentIntent) {\n                throw new PaymentMethodFailedError();\n            }\n\n            return confirmationResult;\n        } catch (error: unknown) {\n            return this.stripeIntegrationService.throwStripeError(stripeError);\n        }\n    }\n\n    private async _completeCheckoutFlow() {\n        if (typeof this._onComplete === 'function') {\n            return this._onComplete();\n        }\n\n        window.location.replace('/order-confirmation');\n\n        return Promise.resolve();\n    }\n\n    private _getPaymentPayload(methodId: string, token?: string): Payment {\n        const cartId = this.paymentIntegrationService.getState().getCart()?.id || '';\n        const formattedPayload = {\n            cart_id: cartId,\n            ...(token ? { credit_card_token: { token } } : {}),\n            confirm: false,\n            method: StripePaymentMethodType.Link,\n        };\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload,\n            },\n        };\n    }\n\n    /** Utils * */\n\n    private _shouldRequireShippingAddress() {\n        const { getCartOrThrow } = this.paymentIntegrationService.getState();\n        const { lineItems } = getCartOrThrow();\n\n        return !!lineItems.physicalItems.length;\n    }\n\n    private async _updateDisplayedPrice() {\n        if (this._stripeElements) {\n            this._stripeElements.update({\n                currency: this._getCurrency(),\n                mode: 'payment',\n                amount: await this._getTotalPrice(),\n            });\n        }\n    }\n\n    private _getCurrency() {\n        if (!this._currencyCode) {\n            const { code: currencyCode } = this.paymentIntegrationService\n                .getState()\n                .getCartOrThrow().currency;\n\n            this._currencyCode = currencyCode.toLowerCase();\n        }\n\n        return this._currencyCode;\n    }\n\n    private async _getTotalPrice(): Promise<number> {\n        await this.paymentIntegrationService.loadCheckout();\n\n        const { getCheckoutOrThrow, getCartOrThrow } = this.paymentIntegrationService.getState();\n        const { decimalPlaces } = getCartOrThrow().currency;\n        const totalPrice = round(getCheckoutOrThrow().outstandingBalance, decimalPlaces).toFixed(\n            decimalPlaces,\n        );\n\n        return this._toCents(+totalPrice);\n    }\n\n    private async _getAvailableCountries(): Promise<string[]> {\n        const countries = await this.paymentIntegrationService.loadShippingCountries();\n        const deliverableCountries =\n            countries.getShippingCountries()?.map((country) => country.code) || [];\n\n        return deliverableCountries.filter((code) => {\n            return expressCheckoutAllowedCountryCodes.includes(code);\n        });\n    }\n\n    private async _getAvailableShippingOptions(): Promise<StripeLinkV2ShippingRate[] | undefined> {\n        const state = this.paymentIntegrationService.getState();\n        const consignments = state.getConsignments();\n\n        if (!consignments?.[0]) {\n            return;\n        }\n\n        const consignment = consignments[0];\n        const options = (consignment.availableShippingOptions || []).map(\n            this._getStripeShippingOption.bind(this),\n        );\n        const recommendedShippingOption = consignment.availableShippingOptions?.find(\n            (shippingOption) => shippingOption.isRecommended,\n        );\n        const selectedId = consignment.selectedShippingOption?.id;\n        const recommendedId = recommendedShippingOption?.id;\n\n        if (selectedId) {\n            // Set selected shipping option first in the array, as it will be selected by default\n            options.sort((option) => (option.id === selectedId ? -1 : 0));\n        } else if (recommendedId) {\n            // Set recommended shipping option first in the array, as it will be selected by default\n            options.sort((option) => (option.id === recommendedId ? -1 : 0));\n            await this._handleShippingOptionChange(recommendedId);\n        } else {\n            await this._handleShippingOptionChange(options[0]?.id);\n        }\n\n        return options;\n    }\n\n    private _getStripeShippingOption({ id, cost, description }: ShippingOption) {\n        return {\n            id,\n            displayName: description,\n            amount: this._toCents(cost),\n        };\n    }\n\n    private async _handleShippingOptionChange(optionId?: string) {\n        if (!optionId || optionId === 'shipping_option_unselected') {\n            return;\n        }\n\n        return this.paymentIntegrationService.selectShippingOption(optionId);\n    }\n\n    private _getAmountTransformer() {\n        if (this._amountTransformer) {\n            return this._amountTransformer;\n        }\n\n        const { getCart } = this.paymentIntegrationService.getState();\n        const { currency } = getCart() || {};\n\n        if (currency) {\n            const amountTransformer = new AmountTransformer(currency.decimalPlaces);\n\n            return amountTransformer;\n        }\n    }\n\n    private _toCents(amount: number) {\n        const fallbackValue = Math.round(amount * 100);\n        const amountTransformer = this._getAmountTransformer();\n\n        if (amountTransformer) {\n            return amountTransformer.toInteger(amount);\n        }\n\n        return fallbackValue;\n    }\n\n    private _toggleLoadingIndicator(isLoading: boolean): void {\n        if (isLoading && this._loadingIndicatorContainer) {\n            this.loadingIndicator.show(this._loadingIndicatorContainer);\n        } else {\n            this.loadingIndicator.hide();\n        }\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    CustomerStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    StripeIntegrationService,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\nimport { DEFAULT_CONTAINER_STYLES, LoadingIndicator } from '@bigcommerce/checkout-sdk/ui';\n\nimport StripeLinkV2CustomerStrategy from './stripe-link-v2-customer-strategy';\n\nconst createStripeLinkV2CustomerStrategy: CustomerStrategyFactory<StripeLinkV2CustomerStrategy> = (\n    paymentIntegrationService,\n) => {\n    const stripeScriptLoader = new StripeScriptLoader(getScriptLoader());\n    const loadingIndicator = new LoadingIndicator({\n        containerStyles: DEFAULT_CONTAINER_STYLES,\n    });\n\n    return new StripeLinkV2CustomerStrategy(\n        paymentIntegrationService,\n        stripeScriptLoader,\n        new StripeIntegrationService(paymentIntegrationService, stripeScriptLoader),\n        loadingIndicator,\n    );\n};\n\nexport default toResolvableModule(createStripeLinkV2CustomerStrategy, [{ id: 'stripeocs' }]);\n","import { round } from 'lodash';\n\nimport {\n    AmountTransformer,\n    CheckoutButtonInitializeOptions,\n    CheckoutButtonStrategy,\n    isRequestError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    Payment,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodFailedError,\n    ShippingOption,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    isStripePaymentMethodLike,\n    StripeAdditionalActionRequired,\n    StripeClient,\n    StripeElement,\n    StripeElementEvent,\n    StripeElements,\n    StripeElementsCreateOptions,\n    StripeElementType,\n    StripeError,\n    StripeEventType,\n    StripeIntegrationService,\n    StripeLinkV2Event,\n    StripeLinkV2Options,\n    StripeLinkV2ShippingRate,\n    StripePaymentMethodType,\n    StripeResult,\n    StripeScriptLoader,\n    StripeStringConstants,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\nimport { LoadingIndicator } from '@bigcommerce/checkout-sdk/ui';\n\nimport { expressCheckoutAllowedCountryCodes } from './constants';\nimport { WithStripeOCSCustomerInitializeOptions } from './stripe-ocs-customer-initialize-options';\n\nexport default class StripeLinkV2ButtonStrategy implements CheckoutButtonStrategy {\n    private _stripeClient?: StripeClient;\n    private _stripeElements?: StripeElements;\n    private _linkV2Element?: StripeElement;\n    private _amountTransformer?: AmountTransformer;\n    private _onComplete?: (orderId?: number) => Promise<never>;\n    private _loadingIndicatorContainer?: string;\n    private _currencyCode?: string;\n    private _captureMethod?: 'automatic' | 'manual';\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private scriptLoader: StripeScriptLoader,\n        private stripeIntegrationService: StripeIntegrationService,\n        private loadingIndicator: LoadingIndicator,\n    ) {}\n\n    async initialize(\n        options: CheckoutButtonInitializeOptions & WithStripeOCSCustomerInitializeOptions,\n    ): Promise<void> {\n        const { stripeocs, containerId } = options || {};\n\n        if (!stripeocs || !containerId) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { methodId, gatewayId } = stripeocs;\n\n        if (!methodId || !gatewayId) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const state = await this.paymentIntegrationService.loadPaymentMethod(gatewayId, {\n            params: { method: methodId },\n        });\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId, gatewayId);\n        const { loadingContainerId, buttonHeight, onComplete } = stripeocs;\n\n        this._loadingIndicatorContainer = loadingContainerId;\n\n        this._onComplete = onComplete;\n\n        if (!isStripePaymentMethodLike(paymentMethod)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { initializationData } = paymentMethod;\n        const { captureMethod } = initializationData;\n        const stripeJsVersion =\n            this.stripeIntegrationService.getStripeJsVersion(initializationData);\n\n        this._captureMethod = captureMethod;\n        this._stripeClient = await this.scriptLoader.getStripeClient(\n            initializationData,\n            state.getCartLocale(),\n            stripeJsVersion,\n        );\n\n        await this.paymentIntegrationService.loadDefaultCheckout();\n\n        await this._mountExpressCheckoutElement(containerId, this._stripeClient, buttonHeight);\n\n        this._initializeEvents(methodId);\n    }\n\n    signIn() {\n        return Promise.resolve();\n    }\n\n    signOut() {\n        return Promise.resolve();\n    }\n\n    executePaymentMethodCheckout() {\n        return Promise.resolve();\n    }\n\n    deinitialize() {\n        return Promise.resolve();\n    }\n\n    private async _mountExpressCheckoutElement(\n        container: string,\n        stripeExpressCheckoutClient: StripeClient,\n        buttonHeight = 40,\n    ) {\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n        const expressCheckoutOptions: StripeElementsCreateOptions = {\n            shippingAddressRequired: shouldRequireShippingAddress,\n            ...(shouldRequireShippingAddress\n                ? { allowedShippingCountries: await this._getAvailableCountries() }\n                : {}),\n            ...(shouldRequireShippingAddress\n                ? { shippingRates: [{ id: '_', amount: 0, displayName: 'Pending rates' }] }\n                : {}),\n            billingAddressRequired: true,\n            emailRequired: true,\n            phoneNumberRequired: true,\n            paymentMethods: {\n                link: StripeStringConstants.AUTO,\n                applePay: StripeStringConstants.NEVER,\n                googlePay: StripeStringConstants.NEVER,\n                amazonPay: StripeStringConstants.NEVER,\n                paypal: StripeStringConstants.NEVER,\n                klarna: StripeStringConstants.NEVER,\n            },\n            // Minimal buttonHeight value is 40\n            buttonHeight,\n        };\n\n        const { cartAmount = 1 } = this.paymentIntegrationService.getState().getCart() || {};\n\n        const elementsOptions: StripeLinkV2Options = {\n            mode: 'payment',\n            amount: this._toCents(cartAmount),\n            currency: this._getCurrency(),\n            ...(this._captureMethod ? { captureMethod: this._captureMethod } : {}),\n        };\n\n        this._stripeElements = stripeExpressCheckoutClient.elements(elementsOptions);\n\n        this._linkV2Element = this._stripeElements.create(\n            StripeElementType.EXPRESS_CHECKOUT,\n            expressCheckoutOptions,\n        );\n        this._linkV2Element.mount(`#${container}`);\n    }\n\n    /** Events * */\n\n    private _initializeEvents(methodId: string): void {\n        if (!this._linkV2Element) {\n            return;\n        }\n\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n\n        if (shouldRequireShippingAddress) {\n            this._linkV2Element.on(StripeElementEvent.SHIPPING_ADDRESS_CHANGE, async (event) =>\n                this._onShippingAddressChange(event),\n            );\n            this._linkV2Element.on(StripeElementEvent.SHIPPING_RATE_CHANGE, async (event) =>\n                this._onShippingRateChange(event),\n            );\n        }\n\n        this._linkV2Element.on(StripeElementEvent.CONFIRM, async (event) =>\n            this._onConfirm(event, methodId),\n        );\n\n        this._linkV2Element.on(StripeElementEvent.CANCEL, this._onCancel);\n    }\n\n    private async _onShippingAddressChange(event: StripeEventType) {\n        if (!('address' in event)) {\n            return;\n        }\n\n        const shippingAddress = event.address;\n        // Depending on the country, some fields can be missing or partially redacted.\n        // For example, the shipping address in the US can only contain a city, state, and ZIP code.\n        // The full shipping address appears in the confirm event object after the purchase is confirmed in the browsers payment interface.\n        const result = {\n            firstName: '',\n            lastName: '',\n            phone: '',\n            company: '',\n            address1: '',\n            address2: '',\n            city: shippingAddress?.city || '',\n            countryCode: shippingAddress?.country || '',\n            postalCode: shippingAddress?.postal_code || '',\n            stateOrProvince: shippingAddress?.state || '',\n            stateOrProvinceCode: shippingAddress?.state || '',\n            customFields: [],\n        };\n\n        await this.paymentIntegrationService.updateShippingAddress(result);\n\n        const shippingRates = await this._getAvailableShippingOptions();\n\n        await this._updateDisplayedPrice();\n\n        if (!shippingRates?.length) {\n            event.reject();\n        } else {\n            event.resolve({\n                shippingRates,\n            });\n        }\n    }\n\n    private _onCancel() {\n        throw new PaymentMethodCancelledError();\n    }\n\n    private async _onShippingRateChange(event: StripeEventType) {\n        if ('shippingRate' in event) {\n            const { shippingRate } = event;\n\n            await this._handleShippingOptionChange(shippingRate?.id);\n\n            await this._updateDisplayedPrice();\n\n            event.resolve({});\n        }\n    }\n\n    /** Confirm methods * */\n    private async _onConfirm(event: StripeEventType, methodId: string) {\n        if (\n            'billingDetails' in event &&\n            'shippingAddress' in event &&\n            this._stripeClient &&\n            this._stripeElements\n        ) {\n            await this._updateShippingAndBillingAddress(event);\n            await this.paymentIntegrationService.submitOrder();\n\n            const paymentPayload = this._getPaymentPayload(methodId);\n\n            try {\n                await this.paymentIntegrationService.submitPayment(paymentPayload);\n            } catch (error) {\n                await this._processAdditionalAction(error, methodId);\n            }\n        }\n\n        return Promise.resolve();\n    }\n\n    private async _updateShippingAndBillingAddress(event: StripeLinkV2Event) {\n        const shouldRequireShippingAddress = this._shouldRequireShippingAddress();\n\n        const firstName =\n            event.shippingAddress?.name?.split(' ')[0] ||\n            event.billingDetails?.name?.split(' ')[0] ||\n            '';\n        const lastName =\n            event.shippingAddress?.name?.split(' ')[1] ||\n            event.billingDetails?.name?.split(' ')[1] ||\n            '';\n\n        if (shouldRequireShippingAddress) {\n            const shippingAddress = this._mapShippingAddress(\n                event.shippingAddress,\n                event.billingDetails,\n                firstName,\n                lastName,\n            );\n\n            await this.paymentIntegrationService.updateShippingAddress(shippingAddress);\n        }\n\n        const billingAddress = this._mapBillingAddress(\n            event.shippingAddress,\n            event.billingDetails,\n            firstName,\n            lastName,\n        );\n\n        await this.paymentIntegrationService.updateBillingAddress(billingAddress);\n    }\n\n    private _mapShippingAddress(\n        shippingAddress: StripeLinkV2Event['shippingAddress'],\n        billingDetails: StripeLinkV2Event['billingDetails'],\n        firstName: string,\n        lastName: string,\n    ) {\n        return {\n            firstName,\n            lastName,\n            phone: billingDetails?.phone || '',\n            company: '',\n            address1: shippingAddress?.address?.line1 || '',\n            address2: shippingAddress?.address?.line2 || '',\n            city: shippingAddress?.address?.city || '',\n            countryCode: shippingAddress?.address?.country || '',\n            postalCode: shippingAddress?.address?.postal_code || '',\n            stateOrProvince: shippingAddress?.address?.state || '',\n            stateOrProvinceCode: shippingAddress?.address?.state || '',\n            customFields: [],\n        };\n    }\n\n    private _mapBillingAddress(\n        shippingAddress: StripeLinkV2Event['shippingAddress'],\n        billingDetails: StripeLinkV2Event['billingDetails'],\n        firstName: string,\n        lastName: string,\n    ) {\n        return {\n            email: billingDetails?.email || '',\n            firstName,\n            lastName,\n            phone: billingDetails?.phone || '',\n            company: '',\n            address1: billingDetails?.address?.line1 || '',\n            address2: '',\n            city: billingDetails?.address?.city || '',\n            countryCode: billingDetails?.address?.country || '',\n            postalCode: billingDetails?.address?.postal_code || '',\n            stateOrProvince: billingDetails?.address?.state || '',\n            stateOrProvinceCode: shippingAddress?.address?.state || '',\n            customFields: [],\n        };\n    }\n\n    private async _processAdditionalAction(error: unknown, methodId: string): Promise<void> {\n        if (\n            !isRequestError(error) ||\n            !this.stripeIntegrationService.isAdditionalActionError(error.body.errors)\n        ) {\n            throw error;\n        }\n\n        if (!this._stripeClient || !this._stripeElements) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        const { data: additionalActionData } = error.body.additional_action_required;\n        const { token } = additionalActionData;\n\n        const { paymentIntent } = await this._confirmStripePaymentOrThrow(\n            additionalActionData,\n            methodId,\n        );\n\n        const paymentPayload = this._getPaymentPayload(methodId, paymentIntent?.id || token);\n\n        try {\n            this._toggleLoadingIndicator(true);\n            await this.paymentIntegrationService.submitPayment(paymentPayload);\n            await this._completeCheckoutFlow();\n        } catch (error) {\n            this.stripeIntegrationService.throwPaymentConfirmationProceedMessage();\n        } finally {\n            this._toggleLoadingIndicator(false);\n        }\n    }\n\n    private async _confirmStripePaymentOrThrow(\n        additionalActionData: StripeAdditionalActionRequired['data'],\n        methodId: string,\n    ): Promise<StripeResult | never> {\n        const { token, redirect_url } = additionalActionData;\n        const stripePaymentData = this.stripeIntegrationService.mapStripePaymentData(\n            this._stripeElements,\n            redirect_url,\n        );\n        let stripeError: StripeError | undefined;\n\n        try {\n            const isPaymentCompleted = await this.stripeIntegrationService.isPaymentCompleted(\n                methodId,\n                this._stripeClient,\n            );\n\n            const confirmationResult = !isPaymentCompleted\n                ? await this._stripeClient?.confirmPayment({\n                      elements: stripePaymentData.elements,\n                      clientSecret: token,\n                      redirect: StripeStringConstants.IF_REQUIRED,\n                      confirmParams: {\n                          return_url: stripePaymentData.confirmParams?.return_url,\n                      },\n                  })\n                : await this._stripeClient?.retrievePaymentIntent(token || '');\n\n            stripeError = confirmationResult?.error;\n\n            if (stripeError || !confirmationResult?.paymentIntent) {\n                throw new PaymentMethodFailedError();\n            }\n\n            return confirmationResult;\n        } catch (error: unknown) {\n            return this.stripeIntegrationService.throwStripeError(stripeError);\n        }\n    }\n\n    private async _completeCheckoutFlow() {\n        if (typeof this._onComplete === 'function') {\n            return this._onComplete();\n        }\n\n        window.location.replace('/checkout/order-confirmation');\n\n        return Promise.resolve();\n    }\n\n    private _getPaymentPayload(methodId: string, token?: string): Payment {\n        const cartId = this.paymentIntegrationService.getState().getCart()?.id || '';\n        const formattedPayload = {\n            cart_id: cartId,\n            ...(token ? { credit_card_token: { token } } : {}),\n            confirm: false,\n            method: StripePaymentMethodType.Link,\n        };\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload,\n            },\n        };\n    }\n\n    /** Utils * */\n\n    private _shouldRequireShippingAddress() {\n        const { getCart } = this.paymentIntegrationService.getState();\n\n        const { lineItems } = getCart() || {};\n\n        return !!lineItems?.physicalItems.length;\n    }\n\n    private async _updateDisplayedPrice() {\n        if (this._stripeElements) {\n            this._stripeElements.update({\n                currency: this._getCurrency(),\n                mode: 'payment',\n                amount: await this._getTotalPrice(),\n            });\n        }\n    }\n\n    private _getCurrency() {\n        if (!this._currencyCode) {\n            const currencyCode = this.paymentIntegrationService.getState().getCart()?.currency;\n\n            if (currencyCode) {\n                this._currencyCode = currencyCode.code.toLowerCase();\n            }\n        }\n\n        return this._currencyCode;\n    }\n\n    private async _getTotalPrice(): Promise<number> {\n        await this.paymentIntegrationService.loadCheckout();\n\n        const { getCheckoutOrThrow, getCart } = this.paymentIntegrationService.getState();\n        const { decimalPlaces } = getCart()?.currency || {};\n        const totalPrice = round(getCheckoutOrThrow().outstandingBalance, decimalPlaces).toFixed(\n            decimalPlaces,\n        );\n\n        return this._toCents(+totalPrice);\n    }\n\n    private async _getAvailableCountries(): Promise<string[]> {\n        const countries = await this.paymentIntegrationService.loadShippingCountries();\n        const deliverableCountries =\n            countries.getShippingCountries()?.map((country) => country.code) || [];\n\n        return deliverableCountries.filter((code) => {\n            return expressCheckoutAllowedCountryCodes.includes(code);\n        });\n    }\n\n    private async _getAvailableShippingOptions(): Promise<StripeLinkV2ShippingRate[] | undefined> {\n        const state = this.paymentIntegrationService.getState();\n        const consignments = state.getConsignments();\n\n        if (!consignments?.[0]) {\n            return;\n        }\n\n        const consignment = consignments[0];\n        const options = (consignment.availableShippingOptions || []).map(\n            this._getStripeShippingOption.bind(this),\n        );\n        const recommendedShippingOption = consignment.availableShippingOptions?.find(\n            (shippingOption) => shippingOption.isRecommended,\n        );\n        const selectedId = consignment.selectedShippingOption?.id;\n        const recommendedId = recommendedShippingOption?.id;\n\n        if (selectedId) {\n            // Set selected shipping option first in the array, as it will be selected by default\n            options.sort((option) => (option.id === selectedId ? -1 : 0));\n        } else if (recommendedId) {\n            // Set recommended shipping option first in the array, as it will be selected by default\n            options.sort((option) => (option.id === recommendedId ? -1 : 0));\n            await this._handleShippingOptionChange(recommendedId);\n        } else {\n            await this._handleShippingOptionChange(options[0]?.id);\n        }\n\n        return options;\n    }\n\n    private _getStripeShippingOption({ id, cost, description }: ShippingOption) {\n        return {\n            id,\n            displayName: description,\n            amount: this._toCents(cost),\n        };\n    }\n\n    private async _handleShippingOptionChange(optionId?: string) {\n        if (!optionId || optionId === 'shipping_option_unselected') {\n            return;\n        }\n\n        return this.paymentIntegrationService.selectShippingOption(optionId);\n    }\n\n    private _getAmountTransformer() {\n        if (this._amountTransformer) {\n            return this._amountTransformer;\n        }\n\n        const { getCart } = this.paymentIntegrationService.getState();\n        const { currency } = getCart() || {};\n\n        if (currency) {\n            const amountTransformer = new AmountTransformer(currency.decimalPlaces);\n\n            return amountTransformer;\n        }\n    }\n\n    private _toCents(amount: number) {\n        const fallbackValue = Math.round(amount * 100);\n        const amountTransformer = this._getAmountTransformer();\n\n        if (amountTransformer) {\n            return amountTransformer.toInteger(amount);\n        }\n\n        return fallbackValue;\n    }\n\n    private _toggleLoadingIndicator(isLoading: boolean): void {\n        if (isLoading && this._loadingIndicatorContainer) {\n            this.loadingIndicator.show(this._loadingIndicatorContainer);\n        } else {\n            this.loadingIndicator.hide();\n        }\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    CheckoutButtonStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\nimport {\n    StripeIntegrationService,\n    StripeScriptLoader,\n} from '@bigcommerce/checkout-sdk/stripe-utils';\nimport { DEFAULT_CONTAINER_STYLES, LoadingIndicator } from '@bigcommerce/checkout-sdk/ui';\n\nimport StripeLinkV2ButtonStrategy from './stripe-link-v2-button-strategy';\n\nconst createLinkV2ButtonStrategy: CheckoutButtonStrategyFactory<StripeLinkV2ButtonStrategy> = (\n    paymentIntegrationService,\n) => {\n    const stripeScriptLoader = new StripeScriptLoader(getScriptLoader());\n    const loadingIndicator = new LoadingIndicator({\n        containerStyles: DEFAULT_CONTAINER_STYLES,\n    });\n\n    return new StripeLinkV2ButtonStrategy(\n        paymentIntegrationService,\n        stripeScriptLoader,\n        new StripeIntegrationService(paymentIntegrationService, stripeScriptLoader),\n        loadingIndicator,\n    );\n};\n\nexport default toResolvableModule(createLinkV2ButtonStrategy, [{ id: 'stripeocs' }]);\n"],"names":["MissingDataErrorType","NotInitializedErrorType","__webpack_require__","toResolvableModule","module","resolveIds","Object","assign","d","exports","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","StandardError","Error","constructor","message","super","name","type","setPrototypeOf","this","__proto__","captureStackTrace","stack","InvalidArgumentError","PaymentArgumentInvalidError","invalidFields","join","isHostedInstrumentLike","instrument","shouldSaveInstrument","shouldSetAsDefaultInstrument","isVaultedInstrument","Boolean","instrumentId","MissingDataError","subtype","MissingBillingAddress","MissingCart","MissingConsignments","MissingCheckout","MissingCustomer","MissingCheckoutConfig","MissingOrderConfig","MissingOrder","MissingOrderId","MissingPayment","MissingPaymentToken","MissingPaymentMethod","MissingShippingAddress","getErrorMessage","OrderFinalizationNotRequiredError","NotInitializedError","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","error","PaymentMethodCancelledError","isIndividualCardElementOptions","individualCardElementOptions","cardNumberElementOptions","cardCvcElementOptions","cardExpiryElementOptions","IconStyle","StripeElementType","StripePaymentMethodType","StripeV3ErrorType","StripeV3Error","AuthFailure","APM_REDIRECT","Alipay","IDEAL","StripeV3PaymentStrategy","paymentIntegrationService","scriptLoader","initialize","options","stripev3","methodId","gatewayId","initializeOptions","isDeinitialize","paymentMethod","getState","getPaymentMethodOrThrow","initializationData","stripePublishableKey","stripeConnectedAccount","useIndividualCardFields","allowRedisplayForStoredInstruments","_allowRedisplayForStoredInstruments","form","getInitializeOptions","stripeV3Client","loadStripeJs","isCreditCard","shouldShowTSVHostedForm","hostedForm","mountCardVerificationFields","stripeElement","mountCardFields","execute","orderRequest","payment","order","formattedPayload","stripeError","paymentData","shouldSubmitOrderBeforeLoadingAPM","includes","isStoreCreditApplied","useStoreCredit","getCheckoutOrThrow","applyStoreCredit","submitOrder","loadPaymentMethod","params","method","state","clientToken","executeWithVaulted","result","confirmStripePayment","id","token","paymentIntent","credit_card_token","vault_payment_instrument","confirm","set_as_default_stored_instrument","CreditCard","client_token","paymentPayload","buildPaymentPayload","submitPayment","processAdditionalAction","handleEmptyPaymentIntentError","finalize","Promise","reject","deinitialize","detach","unmountElement","resolve","isCancellationError","payment_intent","last_payment_error","indexOf","isAuthError","code","isHostedFieldAvailable","definedFields","omitBy","fields","isEmpty","isHostedPaymentFormEnabled","config","isHostedFormEnabled","clientSecret","returnUrl","getStripeJs","confirmAlipayPayment","return_url","handleActions","data","mapStripePaymentData","confirmIdealPayment","Sepa","confirmSepaDebitPayment","card","getStripeCardElements","getStripeElement","billingDetails","mapStripeBillingDetails","getBillingAddress","getCustomer","shouldAllowRedisplay","createPaymentMethod","billing_details","allow_redisplay","bigpay_token","JSON","stringify","validate","submit","loadCurrentOrder","stripeCardElements","some","body","errors","load","getLocale","mapStripeAddress","address","city","countryCode","country","address1","line1","address2","line2","postalCode","stateOrProvinceCode","postal_code","billingAddress","customer","firstName","lastName","trim","zipCodeElementOptions","document","getElementById","containerId","value","addresses","isBillingAddressLike","customerAddress","email","phone","stripePaymentMethodType","payment_method","stripeElements","elements","cardNumberElement","getElement","CardNumber","create","cardExpiryElement","CardExpiry","cardCvcElement","CardCvc","mount","formOptions","storeConfig","getStoreConfig","bigpayBaseUrl","paymentSettings","createHostedForm","attach","isAdditionalActionError","isThreeDSecureRequiredError","action","additional_action_required","redirect_url","window","location","replace","three_ds_result","needsConfirm","catchedConfirmError","confirmCardPayment","getPaymentToken","unmount","undefined","PaymentMethodClientUnavailableError","StripeV3ScriptLoader","stripeWindow","stripeAccount","locale","loadScript","then","Stripe","betas","apiVersion","getScriptLoader","gateway","StripeFormMode","StripeDisplayName","StripeCheckoutSessionStatusType","StripeCheckoutSessionPaymentStatus","StripeLoadActionsResultType","StripeStringConstants","StripeJsVersion","StripePaymentIntentStatus","StripeElementEvent","StripeInstrumentSetupFutureUsage","StripeScriptLoader","getStripeClient","stripeJsVersion","bcStripeClient","stripe","stripeClient","getElements","bcStripeElements","updateStripeElements","update","fetchUpdates","getStripeCheckout","stripeCheckout","bcStripeCheckout","initCheckout","getScriptUrl","V3","PaymentMethodFailedError","StripeIntegrationService","isMounted","checkoutEventsUnsubscribe","initCheckoutEventsSubscription","stripeInitializationOptions","subscribe","paymentElement","PAYMENT","updateStripePaymentIntent","onError","mountElement","getCheckout","outstandingBalance","coupons","mapAppearanceVariables","styles","colorPrimary","fieldInnerShadow","colorBackground","fieldBackground","colorText","labelText","colorDanger","fieldErrorText","colorTextSecondary","colorTextPlaceholder","fieldPlaceholderText","colorIcon","mapInputAppearanceRules","borderColor","fieldBorder","color","fieldText","boxShadow","throwStripeError","throwDisplayableStripeError","errorMessage","throwPaymentConfirmationProceedMessage","isPaymentCompleted","stripeUPEClient","features","getStoreConfigOrThrow","checkoutSettings","retrievePaymentIntent","status","SUCCEEDED","_mapStripeAddress","redirect","IF_REQUIRED","confirmParams","payment_method_data","isRedirectAction","additionalAction","isOnPageAdditionalAction","getStripeJsVersion","useNewStripeJsVersion","CLOVER","DEFAULT_RESPONSE","headers","RequestError","response","isStripePaymentMethodLike","shopperLanguage","supportedLocales","ar","bg","cs","da","de","el","en","es","et","fi","fil","fr","he","hr","hu","it","ja","ko","lt","lv","ms","mt","nb","nl","pl","pt","ro","ru","sk","sl","sv","th","tr","vi","zh","formatLocale","localeLanguage","language","toLowerCase","split","countryLocales","formattedLocale","toUpperCase","STRIPE_UPE_CLIENT_BETAS","STRIPE_UPE_CLIENT_API_VERSION","isStripeAcceleratedCheckoutCustomer","StripeUPEPaymentStrategy","stripeIntegrationService","stripeupe","_loadStripeElement","catch","_stripeElements","_stripeUPEClient","paymentProviderCustomer","getPaymentProviderCustomerOrThrow","stripeLinkAuthenticationState","getCustomerOrThrow","getBillingAddressOrThrow","updateBillingAddress","_executeWithVaulted","_executeWithStripeConfirmation","_getPaymentPayload","_processAdditionalActionWithStripeConfirmation","cartId","getCart","cart_id","_processVaultedAdditionalAction","style","render","initStripeElementUpdateTrigger","enableLink","appearance","_loadStripeJs","_isStripeElementUpdateEnabled","variables","rules","getShippingAddress","NEVER","AUTO","wallets","applePay","googlePay","link","_getStripeElementTerms","on","READY","CHANGE","event","_updateStripeLinkStateByElementType","_updateStripeElement","bind","additionalActionData","_confirmStripePaymentOrThrow","stripePaymentData","confirmationResult","confirmPayment","getCartLocale","shouldShowTerms","terms","paymentElementType","isStripeLinkElementType","Link","updatePaymentProviderCustomer","stripeScriptLoader","isStripePaymentEvent","StripeOCSPaymentStrategy","stripeocs","_initializeStripeElement","_processAdditionalAction","destroy","customerSessionToken","fonts","layout","paymentMethodSelect","handleClosePaymentMethod","togglePreloader","customerSessionClientSecret","savePaymentMethod","maxVisiblePaymentMethods","defaultValues","LOADER_START","_onStripeElementChange","_collapseStripeElement","collapse","paymentMethodOptions","us_bank_account","_shouldSaveInstrument","tokenizedOptions","_getTokenizedOptions","selectedMethodId","client_secret","paymentIntentClientSecret","payment_method_options","collapsed","setupFutureUsage","setup_future_usage","ON_SESSION","OFF_SESSION","tokenized_ach","StripeCSPaymentStrategy","_updateCheckoutSessionData","getPaymentElement","elementsOptions","adaptivePricing","allowed","stripeActions","_getStripeActionsOrThrow","updateEmail","_getStripeElement","actions","loadActions","createPaymentElement","checkoutSessionId","checkoutSessionStatus","paymentStatus","Paid","session","stripeCheckoutSession","StripeUPECustomerStrategy","container","onEmailChange","getStyles","isLoading","entries","forEach","getConsignments","consignments","billingEmail","mode","SHIPPING","linkAuthenticationElement","AUTHENTICATION","authenticated","complete","deleteConsignment","signIn","credentials","signInCustomer","signOut","signOutCustomer","executePaymentMethodCheckout","continueWithCheckoutCallback","DEFAULT_STYLES","size","backgroundColor","DEFAULT_CONTAINER_STYLES","position","ROTATION_ANIMATION","LoadingIndicator","containerStyles","defineAnimation","buildContainer","indicator","buildIndicator","appendChild","show","parentId","parent","visibility","opacity","hide","handleTransitionEnd","removeEventListener","addEventListener","createElement","display","bottom","left","height","width","right","top","transition","setStyleAttribute","borderRadius","border","margin","transform","transformStyle","animation","element","attrs","keys","k","setProperty","head","sheet","CSSStyleSheet","insertRule","AmountTransformer","_decimalPlaces","toInteger","amount","Math","round","expressCheckoutAllowedCountryCodes","StripeLinkV2CustomerStrategy","loadingIndicator","loadingContainerId","buttonHeight","onComplete","_loadingIndicatorContainer","_onComplete","captureMethod","_captureMethod","_stripeClient","_mountExpressCheckoutElement","_initializeEvents","stripeExpressCheckoutClient","shouldRequireShippingAddress","_shouldRequireShippingAddress","expressCheckoutOptions","shippingAddressRequired","allowedShippingCountries","_getAvailableCountries","shippingRates","displayName","billingAddressRequired","emailRequired","phoneNumberRequired","paymentMethods","amazonPay","paypal","klarna","cartAmount","getCartOrThrow","_toCents","currency","_getCurrency","_linkV2Element","EXPRESS_CHECKOUT","SHIPPING_ADDRESS_CHANGE","_onShippingAddressChange","SHIPPING_RATE_CHANGE","_onShippingRateChange","CONFIRM","_onConfirm","CANCEL","_onCancel","shippingAddress","company","stateOrProvince","customFields","updateShippingAddress","_getAvailableShippingOptions","_updateDisplayedPrice","length","shippingRate","_handleShippingOptionChange","_updateShippingAndBillingAddress","_mapShippingAddress","_mapBillingAddress","_toggleLoadingIndicator","_completeCheckoutFlow","lineItems","physicalItems","_getTotalPrice","_currencyCode","currencyCode","loadCheckout","decimalPlaces","totalPrice","toFixed","countries","loadShippingCountries","getShippingCountries","map","filter","consignment","availableShippingOptions","_getStripeShippingOption","recommendedShippingOption","find","shippingOption","isRecommended","selectedId","selectedShippingOption","recommendedId","sort","option","cost","description","optionId","selectShippingOption","_getAmountTransformer","_amountTransformer","fallbackValue","amountTransformer","StripeLinkV2ButtonStrategy","loadDefaultCheckout"],"sourceRoot":""}